// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package github

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-github/sdk/v6/go/github/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource allows you to create and manage GitHub Dependabot secrets within your GitHub repositories.
// You must have write access to a repository to use this resource.
//
// Secret values are encrypted using the [Go '/crypto/box' module](https://godoc.org/golang.org/x/crypto/nacl/box) which is
// interoperable with [libsodium](https://libsodium.gitbook.io/doc/). Libsodium is used by GitHub to decrypt secret values.
//
// For the purposes of security, the contents of the `plaintextValue` field have been marked as `sensitive` to Terraform,
// but it is important to note that **this does not hide it from state files**. You should treat state as sensitive always.
// It is also advised that you do not store plaintext values in your code but rather populate the `encryptedValue`
// using fields from a resource, data source or variable as, while encrypted in state, these will be easily accessible
// in your code. See below for an example of this abstraction.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-github/sdk/v6/go/github"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := github.NewDependabotSecret(ctx, "example_plaintext", &github.DependabotSecretArgs{
//				Repository:     pulumi.String("example_repository"),
//				SecretName:     pulumi.String("example_secret_name"),
//				PlaintextValue: pulumi.Any(someSecretString),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = github.NewDependabotSecret(ctx, "example_encrypted", &github.DependabotSecretArgs{
//				Repository:     pulumi.String("example_repository"),
//				SecretName:     pulumi.String("example_secret_name"),
//				EncryptedValue: pulumi.Any(someEncryptedSecretString),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Example Lifecycle Ignore Changes
//
// This resource supports using the `lifecycle` `ignoreChanges` block on `remoteUpdatedAt` to support use cases where a secret value is created using a placeholder value and then modified after creation outside the scope of Terraform. This approach ensures only the initial placeholder value is referenced in your code and in the resulting state file.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-github/sdk/v6/go/github"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := github.NewDependabotSecret(ctx, "example_allow_drift", &github.DependabotSecretArgs{
//				Repository:     pulumi.String("example_repository"),
//				SecretName:     pulumi.String("example_secret_name"),
//				PlaintextValue: pulumi.String("placeholder"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// This resource can be imported using an ID made of the repository name, and secret name separated by a `:`.
//
// > **Note**: When importing secrets, the `plaintextValue` or `encryptedValue` fields will not be populated in the state. You may need to ignore changes for these as a workaround if you're not planning on updating the secret through Terraform.
//
// ### Import Command
//
// The following command imports a GitHub Dependabot secret named `mysecret` for the repo `myrepo` to a `DependabotSecret` resource named `example`.
//
// ```sh
// $ pulumi import github:index/dependabotSecret:DependabotSecret example myrepo:mysecret
// ```
type DependabotSecret struct {
	pulumi.CustomResourceState

	// Date the secret was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue pulumi.StringPtrOutput `pulumi:"encryptedValue"`
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// Plaintext value of the secret to be encrypted.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	PlaintextValue pulumi.StringPtrOutput `pulumi:"plaintextValue"`
	// Date the secret was last updated in GitHub.
	RemoteUpdatedAt pulumi.StringOutput `pulumi:"remoteUpdatedAt"`
	// Name of the repository.
	Repository pulumi.StringOutput `pulumi:"repository"`
	// ID of the repository.
	RepositoryId pulumi.IntOutput `pulumi:"repositoryId"`
	// Name of the secret.
	SecretName pulumi.StringOutput `pulumi:"secretName"`
	// Date the secret was last updated by the provider.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
}

// NewDependabotSecret registers a new resource with the given unique name, arguments, and options.
func NewDependabotSecret(ctx *pulumi.Context,
	name string, args *DependabotSecretArgs, opts ...pulumi.ResourceOption) (*DependabotSecret, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Repository == nil {
		return nil, errors.New("invalid value for required argument 'Repository'")
	}
	if args.SecretName == nil {
		return nil, errors.New("invalid value for required argument 'SecretName'")
	}
	if args.EncryptedValue != nil {
		args.EncryptedValue = pulumi.ToSecret(args.EncryptedValue).(pulumi.StringPtrInput)
	}
	if args.PlaintextValue != nil {
		args.PlaintextValue = pulumi.ToSecret(args.PlaintextValue).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"encryptedValue",
		"plaintextValue",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DependabotSecret
	err := ctx.RegisterResource("github:index/dependabotSecret:DependabotSecret", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDependabotSecret gets an existing DependabotSecret resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDependabotSecret(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DependabotSecretState, opts ...pulumi.ResourceOption) (*DependabotSecret, error) {
	var resource DependabotSecret
	err := ctx.ReadResource("github:index/dependabotSecret:DependabotSecret", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DependabotSecret resources.
type dependabotSecretState struct {
	// Date the secret was created.
	CreatedAt *string `pulumi:"createdAt"`
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue *string `pulumi:"encryptedValue"`
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId *string `pulumi:"keyId"`
	// Plaintext value of the secret to be encrypted.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	PlaintextValue *string `pulumi:"plaintextValue"`
	// Date the secret was last updated in GitHub.
	RemoteUpdatedAt *string `pulumi:"remoteUpdatedAt"`
	// Name of the repository.
	Repository *string `pulumi:"repository"`
	// ID of the repository.
	RepositoryId *int `pulumi:"repositoryId"`
	// Name of the secret.
	SecretName *string `pulumi:"secretName"`
	// Date the secret was last updated by the provider.
	UpdatedAt *string `pulumi:"updatedAt"`
}

type DependabotSecretState struct {
	// Date the secret was created.
	CreatedAt pulumi.StringPtrInput
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue pulumi.StringPtrInput
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId pulumi.StringPtrInput
	// Plaintext value of the secret to be encrypted.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	PlaintextValue pulumi.StringPtrInput
	// Date the secret was last updated in GitHub.
	RemoteUpdatedAt pulumi.StringPtrInput
	// Name of the repository.
	Repository pulumi.StringPtrInput
	// ID of the repository.
	RepositoryId pulumi.IntPtrInput
	// Name of the secret.
	SecretName pulumi.StringPtrInput
	// Date the secret was last updated by the provider.
	UpdatedAt pulumi.StringPtrInput
}

func (DependabotSecretState) ElementType() reflect.Type {
	return reflect.TypeOf((*dependabotSecretState)(nil)).Elem()
}

type dependabotSecretArgs struct {
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue *string `pulumi:"encryptedValue"`
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId *string `pulumi:"keyId"`
	// Plaintext value of the secret to be encrypted.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	PlaintextValue *string `pulumi:"plaintextValue"`
	// Name of the repository.
	Repository string `pulumi:"repository"`
	// Name of the secret.
	SecretName string `pulumi:"secretName"`
}

// The set of arguments for constructing a DependabotSecret resource.
type DependabotSecretArgs struct {
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue pulumi.StringPtrInput
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId pulumi.StringPtrInput
	// Plaintext value of the secret to be encrypted.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	PlaintextValue pulumi.StringPtrInput
	// Name of the repository.
	Repository pulumi.StringInput
	// Name of the secret.
	SecretName pulumi.StringInput
}

func (DependabotSecretArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*dependabotSecretArgs)(nil)).Elem()
}

type DependabotSecretInput interface {
	pulumi.Input

	ToDependabotSecretOutput() DependabotSecretOutput
	ToDependabotSecretOutputWithContext(ctx context.Context) DependabotSecretOutput
}

func (*DependabotSecret) ElementType() reflect.Type {
	return reflect.TypeOf((**DependabotSecret)(nil)).Elem()
}

func (i *DependabotSecret) ToDependabotSecretOutput() DependabotSecretOutput {
	return i.ToDependabotSecretOutputWithContext(context.Background())
}

func (i *DependabotSecret) ToDependabotSecretOutputWithContext(ctx context.Context) DependabotSecretOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DependabotSecretOutput)
}

// DependabotSecretArrayInput is an input type that accepts DependabotSecretArray and DependabotSecretArrayOutput values.
// You can construct a concrete instance of `DependabotSecretArrayInput` via:
//
//	DependabotSecretArray{ DependabotSecretArgs{...} }
type DependabotSecretArrayInput interface {
	pulumi.Input

	ToDependabotSecretArrayOutput() DependabotSecretArrayOutput
	ToDependabotSecretArrayOutputWithContext(context.Context) DependabotSecretArrayOutput
}

type DependabotSecretArray []DependabotSecretInput

func (DependabotSecretArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DependabotSecret)(nil)).Elem()
}

func (i DependabotSecretArray) ToDependabotSecretArrayOutput() DependabotSecretArrayOutput {
	return i.ToDependabotSecretArrayOutputWithContext(context.Background())
}

func (i DependabotSecretArray) ToDependabotSecretArrayOutputWithContext(ctx context.Context) DependabotSecretArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DependabotSecretArrayOutput)
}

// DependabotSecretMapInput is an input type that accepts DependabotSecretMap and DependabotSecretMapOutput values.
// You can construct a concrete instance of `DependabotSecretMapInput` via:
//
//	DependabotSecretMap{ "key": DependabotSecretArgs{...} }
type DependabotSecretMapInput interface {
	pulumi.Input

	ToDependabotSecretMapOutput() DependabotSecretMapOutput
	ToDependabotSecretMapOutputWithContext(context.Context) DependabotSecretMapOutput
}

type DependabotSecretMap map[string]DependabotSecretInput

func (DependabotSecretMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DependabotSecret)(nil)).Elem()
}

func (i DependabotSecretMap) ToDependabotSecretMapOutput() DependabotSecretMapOutput {
	return i.ToDependabotSecretMapOutputWithContext(context.Background())
}

func (i DependabotSecretMap) ToDependabotSecretMapOutputWithContext(ctx context.Context) DependabotSecretMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DependabotSecretMapOutput)
}

type DependabotSecretOutput struct{ *pulumi.OutputState }

func (DependabotSecretOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DependabotSecret)(nil)).Elem()
}

func (o DependabotSecretOutput) ToDependabotSecretOutput() DependabotSecretOutput {
	return o
}

func (o DependabotSecretOutput) ToDependabotSecretOutputWithContext(ctx context.Context) DependabotSecretOutput {
	return o
}

// Date the secret was created.
func (o DependabotSecretOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Encrypted value of the secret using the GitHub public key in Base64 format.
func (o DependabotSecretOutput) EncryptedValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.StringPtrOutput { return v.EncryptedValue }).(pulumi.StringPtrOutput)
}

// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
func (o DependabotSecretOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// Plaintext value of the secret to be encrypted.
//
// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
func (o DependabotSecretOutput) PlaintextValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.StringPtrOutput { return v.PlaintextValue }).(pulumi.StringPtrOutput)
}

// Date the secret was last updated in GitHub.
func (o DependabotSecretOutput) RemoteUpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.StringOutput { return v.RemoteUpdatedAt }).(pulumi.StringOutput)
}

// Name of the repository.
func (o DependabotSecretOutput) Repository() pulumi.StringOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.StringOutput { return v.Repository }).(pulumi.StringOutput)
}

// ID of the repository.
func (o DependabotSecretOutput) RepositoryId() pulumi.IntOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.IntOutput { return v.RepositoryId }).(pulumi.IntOutput)
}

// Name of the secret.
func (o DependabotSecretOutput) SecretName() pulumi.StringOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.StringOutput { return v.SecretName }).(pulumi.StringOutput)
}

// Date the secret was last updated by the provider.
func (o DependabotSecretOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *DependabotSecret) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

type DependabotSecretArrayOutput struct{ *pulumi.OutputState }

func (DependabotSecretArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DependabotSecret)(nil)).Elem()
}

func (o DependabotSecretArrayOutput) ToDependabotSecretArrayOutput() DependabotSecretArrayOutput {
	return o
}

func (o DependabotSecretArrayOutput) ToDependabotSecretArrayOutputWithContext(ctx context.Context) DependabotSecretArrayOutput {
	return o
}

func (o DependabotSecretArrayOutput) Index(i pulumi.IntInput) DependabotSecretOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DependabotSecret {
		return vs[0].([]*DependabotSecret)[vs[1].(int)]
	}).(DependabotSecretOutput)
}

type DependabotSecretMapOutput struct{ *pulumi.OutputState }

func (DependabotSecretMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DependabotSecret)(nil)).Elem()
}

func (o DependabotSecretMapOutput) ToDependabotSecretMapOutput() DependabotSecretMapOutput {
	return o
}

func (o DependabotSecretMapOutput) ToDependabotSecretMapOutputWithContext(ctx context.Context) DependabotSecretMapOutput {
	return o
}

func (o DependabotSecretMapOutput) MapIndex(k pulumi.StringInput) DependabotSecretOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DependabotSecret {
		return vs[0].(map[string]*DependabotSecret)[vs[1].(string)]
	}).(DependabotSecretOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DependabotSecretInput)(nil)).Elem(), &DependabotSecret{})
	pulumi.RegisterInputType(reflect.TypeOf((*DependabotSecretArrayInput)(nil)).Elem(), DependabotSecretArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DependabotSecretMapInput)(nil)).Elem(), DependabotSecretMap{})
	pulumi.RegisterOutputType(DependabotSecretOutput{})
	pulumi.RegisterOutputType(DependabotSecretArrayOutput{})
	pulumi.RegisterOutputType(DependabotSecretMapOutput{})
}
