// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package github

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-github/sdk/v6/go/github/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// ### Import Command
//
// The following command imports a GitHub actions secret named `mysecret` for the repo `myrepo` to a `github_actions_secret` resource named `example`.
//
// ```sh
// $ pulumi import github:index/actionsSecret:ActionsSecret example myrepo:mysecret
// ```
type ActionsSecret struct {
	pulumi.CustomResourceState

	// Date the secret was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// (Optional) This is ignored as drift detection is built into the resource.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	//
	// Deprecated: This is no longer required and will be removed in a future release. Drift detection is now always performed, and external changes will result in the secret being updated to match the Terraform configuration. If you want to ignore external changes, you can use the `lifecycle` block with `ignoreChanges` on the `remoteUpdatedAt` field.
	DestroyOnDrift pulumi.BoolPtrOutput `pulumi:"destroyOnDrift"`
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue pulumi.StringPtrOutput `pulumi:"encryptedValue"`
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// Plaintext value of the secret to be encrypted.
	PlaintextValue pulumi.StringPtrOutput `pulumi:"plaintextValue"`
	// Date the secret was last updated in GitHub.
	RemoteUpdatedAt pulumi.StringOutput `pulumi:"remoteUpdatedAt"`
	// Name of the repository.
	Repository pulumi.StringOutput `pulumi:"repository"`
	// ID of the repository.
	RepositoryId pulumi.IntOutput `pulumi:"repositoryId"`
	// Name of the secret.
	SecretName pulumi.StringOutput `pulumi:"secretName"`
	// Date the secret was last updated by the provider.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
}

// NewActionsSecret registers a new resource with the given unique name, arguments, and options.
func NewActionsSecret(ctx *pulumi.Context,
	name string, args *ActionsSecretArgs, opts ...pulumi.ResourceOption) (*ActionsSecret, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Repository == nil {
		return nil, errors.New("invalid value for required argument 'Repository'")
	}
	if args.SecretName == nil {
		return nil, errors.New("invalid value for required argument 'SecretName'")
	}
	if args.EncryptedValue != nil {
		args.EncryptedValue = pulumi.ToSecret(args.EncryptedValue).(pulumi.StringPtrInput)
	}
	if args.PlaintextValue != nil {
		args.PlaintextValue = pulumi.ToSecret(args.PlaintextValue).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"encryptedValue",
		"plaintextValue",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ActionsSecret
	err := ctx.RegisterResource("github:index/actionsSecret:ActionsSecret", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetActionsSecret gets an existing ActionsSecret resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetActionsSecret(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ActionsSecretState, opts ...pulumi.ResourceOption) (*ActionsSecret, error) {
	var resource ActionsSecret
	err := ctx.ReadResource("github:index/actionsSecret:ActionsSecret", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ActionsSecret resources.
type actionsSecretState struct {
	// Date the secret was created.
	CreatedAt *string `pulumi:"createdAt"`
	// (Optional) This is ignored as drift detection is built into the resource.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	//
	// Deprecated: This is no longer required and will be removed in a future release. Drift detection is now always performed, and external changes will result in the secret being updated to match the Terraform configuration. If you want to ignore external changes, you can use the `lifecycle` block with `ignoreChanges` on the `remoteUpdatedAt` field.
	DestroyOnDrift *bool `pulumi:"destroyOnDrift"`
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue *string `pulumi:"encryptedValue"`
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId *string `pulumi:"keyId"`
	// Plaintext value of the secret to be encrypted.
	PlaintextValue *string `pulumi:"plaintextValue"`
	// Date the secret was last updated in GitHub.
	RemoteUpdatedAt *string `pulumi:"remoteUpdatedAt"`
	// Name of the repository.
	Repository *string `pulumi:"repository"`
	// ID of the repository.
	RepositoryId *int `pulumi:"repositoryId"`
	// Name of the secret.
	SecretName *string `pulumi:"secretName"`
	// Date the secret was last updated by the provider.
	UpdatedAt *string `pulumi:"updatedAt"`
}

type ActionsSecretState struct {
	// Date the secret was created.
	CreatedAt pulumi.StringPtrInput
	// (Optional) This is ignored as drift detection is built into the resource.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	//
	// Deprecated: This is no longer required and will be removed in a future release. Drift detection is now always performed, and external changes will result in the secret being updated to match the Terraform configuration. If you want to ignore external changes, you can use the `lifecycle` block with `ignoreChanges` on the `remoteUpdatedAt` field.
	DestroyOnDrift pulumi.BoolPtrInput
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue pulumi.StringPtrInput
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId pulumi.StringPtrInput
	// Plaintext value of the secret to be encrypted.
	PlaintextValue pulumi.StringPtrInput
	// Date the secret was last updated in GitHub.
	RemoteUpdatedAt pulumi.StringPtrInput
	// Name of the repository.
	Repository pulumi.StringPtrInput
	// ID of the repository.
	RepositoryId pulumi.IntPtrInput
	// Name of the secret.
	SecretName pulumi.StringPtrInput
	// Date the secret was last updated by the provider.
	UpdatedAt pulumi.StringPtrInput
}

func (ActionsSecretState) ElementType() reflect.Type {
	return reflect.TypeOf((*actionsSecretState)(nil)).Elem()
}

type actionsSecretArgs struct {
	// (Optional) This is ignored as drift detection is built into the resource.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	//
	// Deprecated: This is no longer required and will be removed in a future release. Drift detection is now always performed, and external changes will result in the secret being updated to match the Terraform configuration. If you want to ignore external changes, you can use the `lifecycle` block with `ignoreChanges` on the `remoteUpdatedAt` field.
	DestroyOnDrift *bool `pulumi:"destroyOnDrift"`
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue *string `pulumi:"encryptedValue"`
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId *string `pulumi:"keyId"`
	// Plaintext value of the secret to be encrypted.
	PlaintextValue *string `pulumi:"plaintextValue"`
	// Name of the repository.
	Repository string `pulumi:"repository"`
	// Name of the secret.
	SecretName string `pulumi:"secretName"`
}

// The set of arguments for constructing a ActionsSecret resource.
type ActionsSecretArgs struct {
	// (Optional) This is ignored as drift detection is built into the resource.
	//
	// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
	//
	// Deprecated: This is no longer required and will be removed in a future release. Drift detection is now always performed, and external changes will result in the secret being updated to match the Terraform configuration. If you want to ignore external changes, you can use the `lifecycle` block with `ignoreChanges` on the `remoteUpdatedAt` field.
	DestroyOnDrift pulumi.BoolPtrInput
	// Encrypted value of the secret using the GitHub public key in Base64 format.
	EncryptedValue pulumi.StringPtrInput
	// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
	KeyId pulumi.StringPtrInput
	// Plaintext value of the secret to be encrypted.
	PlaintextValue pulumi.StringPtrInput
	// Name of the repository.
	Repository pulumi.StringInput
	// Name of the secret.
	SecretName pulumi.StringInput
}

func (ActionsSecretArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*actionsSecretArgs)(nil)).Elem()
}

type ActionsSecretInput interface {
	pulumi.Input

	ToActionsSecretOutput() ActionsSecretOutput
	ToActionsSecretOutputWithContext(ctx context.Context) ActionsSecretOutput
}

func (*ActionsSecret) ElementType() reflect.Type {
	return reflect.TypeOf((**ActionsSecret)(nil)).Elem()
}

func (i *ActionsSecret) ToActionsSecretOutput() ActionsSecretOutput {
	return i.ToActionsSecretOutputWithContext(context.Background())
}

func (i *ActionsSecret) ToActionsSecretOutputWithContext(ctx context.Context) ActionsSecretOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActionsSecretOutput)
}

// ActionsSecretArrayInput is an input type that accepts ActionsSecretArray and ActionsSecretArrayOutput values.
// You can construct a concrete instance of `ActionsSecretArrayInput` via:
//
//	ActionsSecretArray{ ActionsSecretArgs{...} }
type ActionsSecretArrayInput interface {
	pulumi.Input

	ToActionsSecretArrayOutput() ActionsSecretArrayOutput
	ToActionsSecretArrayOutputWithContext(context.Context) ActionsSecretArrayOutput
}

type ActionsSecretArray []ActionsSecretInput

func (ActionsSecretArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ActionsSecret)(nil)).Elem()
}

func (i ActionsSecretArray) ToActionsSecretArrayOutput() ActionsSecretArrayOutput {
	return i.ToActionsSecretArrayOutputWithContext(context.Background())
}

func (i ActionsSecretArray) ToActionsSecretArrayOutputWithContext(ctx context.Context) ActionsSecretArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActionsSecretArrayOutput)
}

// ActionsSecretMapInput is an input type that accepts ActionsSecretMap and ActionsSecretMapOutput values.
// You can construct a concrete instance of `ActionsSecretMapInput` via:
//
//	ActionsSecretMap{ "key": ActionsSecretArgs{...} }
type ActionsSecretMapInput interface {
	pulumi.Input

	ToActionsSecretMapOutput() ActionsSecretMapOutput
	ToActionsSecretMapOutputWithContext(context.Context) ActionsSecretMapOutput
}

type ActionsSecretMap map[string]ActionsSecretInput

func (ActionsSecretMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ActionsSecret)(nil)).Elem()
}

func (i ActionsSecretMap) ToActionsSecretMapOutput() ActionsSecretMapOutput {
	return i.ToActionsSecretMapOutputWithContext(context.Background())
}

func (i ActionsSecretMap) ToActionsSecretMapOutputWithContext(ctx context.Context) ActionsSecretMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ActionsSecretMapOutput)
}

type ActionsSecretOutput struct{ *pulumi.OutputState }

func (ActionsSecretOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ActionsSecret)(nil)).Elem()
}

func (o ActionsSecretOutput) ToActionsSecretOutput() ActionsSecretOutput {
	return o
}

func (o ActionsSecretOutput) ToActionsSecretOutputWithContext(ctx context.Context) ActionsSecretOutput {
	return o
}

// Date the secret was created.
func (o ActionsSecretOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// (Optional) This is ignored as drift detection is built into the resource.
//
// > **Note**: One of either `encryptedValue` or `plaintextValue` must be specified.
//
// Deprecated: This is no longer required and will be removed in a future release. Drift detection is now always performed, and external changes will result in the secret being updated to match the Terraform configuration. If you want to ignore external changes, you can use the `lifecycle` block with `ignoreChanges` on the `remoteUpdatedAt` field.
func (o ActionsSecretOutput) DestroyOnDrift() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.BoolPtrOutput { return v.DestroyOnDrift }).(pulumi.BoolPtrOutput)
}

// Encrypted value of the secret using the GitHub public key in Base64 format.
func (o ActionsSecretOutput) EncryptedValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.StringPtrOutput { return v.EncryptedValue }).(pulumi.StringPtrOutput)
}

// ID of the public key used to encrypt the secret. This should be provided when setting `encryptedValue`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintextValue`.
func (o ActionsSecretOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// Plaintext value of the secret to be encrypted.
func (o ActionsSecretOutput) PlaintextValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.StringPtrOutput { return v.PlaintextValue }).(pulumi.StringPtrOutput)
}

// Date the secret was last updated in GitHub.
func (o ActionsSecretOutput) RemoteUpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.StringOutput { return v.RemoteUpdatedAt }).(pulumi.StringOutput)
}

// Name of the repository.
func (o ActionsSecretOutput) Repository() pulumi.StringOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.StringOutput { return v.Repository }).(pulumi.StringOutput)
}

// ID of the repository.
func (o ActionsSecretOutput) RepositoryId() pulumi.IntOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.IntOutput { return v.RepositoryId }).(pulumi.IntOutput)
}

// Name of the secret.
func (o ActionsSecretOutput) SecretName() pulumi.StringOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.StringOutput { return v.SecretName }).(pulumi.StringOutput)
}

// Date the secret was last updated by the provider.
func (o ActionsSecretOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *ActionsSecret) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

type ActionsSecretArrayOutput struct{ *pulumi.OutputState }

func (ActionsSecretArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ActionsSecret)(nil)).Elem()
}

func (o ActionsSecretArrayOutput) ToActionsSecretArrayOutput() ActionsSecretArrayOutput {
	return o
}

func (o ActionsSecretArrayOutput) ToActionsSecretArrayOutputWithContext(ctx context.Context) ActionsSecretArrayOutput {
	return o
}

func (o ActionsSecretArrayOutput) Index(i pulumi.IntInput) ActionsSecretOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ActionsSecret {
		return vs[0].([]*ActionsSecret)[vs[1].(int)]
	}).(ActionsSecretOutput)
}

type ActionsSecretMapOutput struct{ *pulumi.OutputState }

func (ActionsSecretMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ActionsSecret)(nil)).Elem()
}

func (o ActionsSecretMapOutput) ToActionsSecretMapOutput() ActionsSecretMapOutput {
	return o
}

func (o ActionsSecretMapOutput) ToActionsSecretMapOutputWithContext(ctx context.Context) ActionsSecretMapOutput {
	return o
}

func (o ActionsSecretMapOutput) MapIndex(k pulumi.StringInput) ActionsSecretOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ActionsSecret {
		return vs[0].(map[string]*ActionsSecret)[vs[1].(string)]
	}).(ActionsSecretOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ActionsSecretInput)(nil)).Elem(), &ActionsSecret{})
	pulumi.RegisterInputType(reflect.TypeOf((*ActionsSecretArrayInput)(nil)).Elem(), ActionsSecretArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ActionsSecretMapInput)(nil)).Elem(), ActionsSecretMap{})
	pulumi.RegisterOutputType(ActionsSecretOutput{})
	pulumi.RegisterOutputType(ActionsSecretArrayOutput{})
	pulumi.RegisterOutputType(ActionsSecretMapOutput{})
}
