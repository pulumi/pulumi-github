# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = ['DependabotSecretArgs', 'DependabotSecret']

@pulumi.input_type
class DependabotSecretArgs:
    def __init__(__self__, *,
                 repository: pulumi.Input[_builtins.str],
                 secret_name: pulumi.Input[_builtins.str],
                 encrypted_value: Optional[pulumi.Input[_builtins.str]] = None,
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 plaintext_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The set of arguments for constructing a DependabotSecret resource.
        :param pulumi.Input[_builtins.str] repository: Name of the repository.
        :param pulumi.Input[_builtins.str] secret_name: Name of the secret.
        :param pulumi.Input[_builtins.str] encrypted_value: Encrypted value of the secret using the GitHub public key in Base64 format.
        :param pulumi.Input[_builtins.str] key_id: ID of the public key used to encrypt the secret. This should be provided when setting `encrypted_value`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintext_value`.
        :param pulumi.Input[_builtins.str] plaintext_value: Plaintext value of the secret to be encrypted.
               
               > **Note**: One of either `encrypted_value` or `plaintext_value` must be specified.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "secret_name", secret_name)
        if encrypted_value is not None:
            pulumi.set(__self__, "encrypted_value", encrypted_value)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if plaintext_value is not None:
            pulumi.set(__self__, "plaintext_value", plaintext_value)

    @_builtins.property
    @pulumi.getter
    def repository(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "repository", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the secret.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter(name="encryptedValue")
    def encrypted_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Encrypted value of the secret using the GitHub public key in Base64 format.
        """
        return pulumi.get(self, "encrypted_value")

    @encrypted_value.setter
    def encrypted_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encrypted_value", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the public key used to encrypt the secret. This should be provided when setting `encrypted_value`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintext_value`.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="plaintextValue")
    def plaintext_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plaintext value of the secret to be encrypted.

        > **Note**: One of either `encrypted_value` or `plaintext_value` must be specified.
        """
        return pulumi.get(self, "plaintext_value")

    @plaintext_value.setter
    def plaintext_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plaintext_value", value)


@pulumi.input_type
class _DependabotSecretState:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 encrypted_value: Optional[pulumi.Input[_builtins.str]] = None,
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 plaintext_value: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 repository: Optional[pulumi.Input[_builtins.str]] = None,
                 repository_id: Optional[pulumi.Input[_builtins.int]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input properties used for looking up and filtering DependabotSecret resources.
        :param pulumi.Input[_builtins.str] created_at: Date the secret was created.
        :param pulumi.Input[_builtins.str] encrypted_value: Encrypted value of the secret using the GitHub public key in Base64 format.
        :param pulumi.Input[_builtins.str] key_id: ID of the public key used to encrypt the secret. This should be provided when setting `encrypted_value`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintext_value`.
        :param pulumi.Input[_builtins.str] plaintext_value: Plaintext value of the secret to be encrypted.
               
               > **Note**: One of either `encrypted_value` or `plaintext_value` must be specified.
        :param pulumi.Input[_builtins.str] remote_updated_at: Date the secret was last updated in GitHub.
        :param pulumi.Input[_builtins.str] repository: Name of the repository.
        :param pulumi.Input[_builtins.int] repository_id: ID of the repository.
        :param pulumi.Input[_builtins.str] secret_name: Name of the secret.
        :param pulumi.Input[_builtins.str] updated_at: Date the secret was last updated by the provider.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if encrypted_value is not None:
            pulumi.set(__self__, "encrypted_value", encrypted_value)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if plaintext_value is not None:
            pulumi.set(__self__, "plaintext_value", plaintext_value)
        if remote_updated_at is not None:
            pulumi.set(__self__, "remote_updated_at", remote_updated_at)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date the secret was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="encryptedValue")
    def encrypted_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Encrypted value of the secret using the GitHub public key in Base64 format.
        """
        return pulumi.get(self, "encrypted_value")

    @encrypted_value.setter
    def encrypted_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encrypted_value", value)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the public key used to encrypt the secret. This should be provided when setting `encrypted_value`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintext_value`.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_id", value)

    @_builtins.property
    @pulumi.getter(name="plaintextValue")
    def plaintext_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Plaintext value of the secret to be encrypted.

        > **Note**: One of either `encrypted_value` or `plaintext_value` must be specified.
        """
        return pulumi.get(self, "plaintext_value")

    @plaintext_value.setter
    def plaintext_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plaintext_value", value)

    @_builtins.property
    @pulumi.getter(name="remoteUpdatedAt")
    def remote_updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date the secret was last updated in GitHub.
        """
        return pulumi.get(self, "remote_updated_at")

    @remote_updated_at.setter
    def remote_updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_updated_at", value)

    @_builtins.property
    @pulumi.getter
    def repository(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository", value)

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        ID of the repository.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "repository_id", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the secret.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Date the secret was last updated by the provider.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


@pulumi.type_token("github:index/dependabotSecret:DependabotSecret")
class DependabotSecret(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 encrypted_value: Optional[pulumi.Input[_builtins.str]] = None,
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 plaintext_value: Optional[pulumi.Input[_builtins.str]] = None,
                 repository: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        """
        This resource allows you to create and manage GitHub Dependabot secrets within your GitHub repositories.
        You must have write access to a repository to use this resource.

        Secret values are encrypted using the [Go '/crypto/box' module](https://godoc.org/golang.org/x/crypto/nacl/box) which is
        interoperable with [libsodium](https://libsodium.gitbook.io/doc/). Libsodium is used by GitHub to decrypt secret values.

        For the purposes of security, the contents of the `plaintext_value` field have been marked as `sensitive` to Terraform,
        but it is important to note that **this does not hide it from state files**. You should treat state as sensitive always.
        It is also advised that you do not store plaintext values in your code but rather populate the `encrypted_value`
        using fields from a resource, data source or variable as, while encrypted in state, these will be easily accessible
        in your code. See below for an example of this abstraction.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_github as github

        example_plaintext = github.DependabotSecret("example_plaintext",
            repository="example_repository",
            secret_name="example_secret_name",
            plaintext_value=some_secret_string)
        example_encrypted = github.DependabotSecret("example_encrypted",
            repository="example_repository",
            secret_name="example_secret_name",
            encrypted_value=some_encrypted_secret_string)
        ```

        ## Example Lifecycle Ignore Changes

        This resource supports using the `lifecycle` `ignore_changes` block on `remote_updated_at` to support use cases where a secret value is created using a placeholder value and then modified after creation outside the scope of Terraform. This approach ensures only the initial placeholder value is referenced in your code and in the resulting state file.

        ```python
        import pulumi
        import pulumi_github as github

        example_allow_drift = github.DependabotSecret("example_allow_drift",
            repository="example_repository",
            secret_name="example_secret_name",
            plaintext_value="placeholder")
        ```

        ## Import

        This resource can be imported using an ID made of the repository name, and secret name separated by a `:`.

        > **Note**: When importing secrets, the `plaintext_value` or `encrypted_value` fields will not be populated in the state. You may need to ignore changes for these as a workaround if you're not planning on updating the secret through Terraform.

        ### Import Command

        The following command imports a GitHub Dependabot secret named `mysecret` for the repo `myrepo` to a `DependabotSecret` resource named `example`.

        ```sh
        $ pulumi import github:index/dependabotSecret:DependabotSecret example myrepo:mysecret
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] encrypted_value: Encrypted value of the secret using the GitHub public key in Base64 format.
        :param pulumi.Input[_builtins.str] key_id: ID of the public key used to encrypt the secret. This should be provided when setting `encrypted_value`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintext_value`.
        :param pulumi.Input[_builtins.str] plaintext_value: Plaintext value of the secret to be encrypted.
               
               > **Note**: One of either `encrypted_value` or `plaintext_value` must be specified.
        :param pulumi.Input[_builtins.str] repository: Name of the repository.
        :param pulumi.Input[_builtins.str] secret_name: Name of the secret.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: DependabotSecretArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        This resource allows you to create and manage GitHub Dependabot secrets within your GitHub repositories.
        You must have write access to a repository to use this resource.

        Secret values are encrypted using the [Go '/crypto/box' module](https://godoc.org/golang.org/x/crypto/nacl/box) which is
        interoperable with [libsodium](https://libsodium.gitbook.io/doc/). Libsodium is used by GitHub to decrypt secret values.

        For the purposes of security, the contents of the `plaintext_value` field have been marked as `sensitive` to Terraform,
        but it is important to note that **this does not hide it from state files**. You should treat state as sensitive always.
        It is also advised that you do not store plaintext values in your code but rather populate the `encrypted_value`
        using fields from a resource, data source or variable as, while encrypted in state, these will be easily accessible
        in your code. See below for an example of this abstraction.

        ## Example Usage

        ```python
        import pulumi
        import pulumi_github as github

        example_plaintext = github.DependabotSecret("example_plaintext",
            repository="example_repository",
            secret_name="example_secret_name",
            plaintext_value=some_secret_string)
        example_encrypted = github.DependabotSecret("example_encrypted",
            repository="example_repository",
            secret_name="example_secret_name",
            encrypted_value=some_encrypted_secret_string)
        ```

        ## Example Lifecycle Ignore Changes

        This resource supports using the `lifecycle` `ignore_changes` block on `remote_updated_at` to support use cases where a secret value is created using a placeholder value and then modified after creation outside the scope of Terraform. This approach ensures only the initial placeholder value is referenced in your code and in the resulting state file.

        ```python
        import pulumi
        import pulumi_github as github

        example_allow_drift = github.DependabotSecret("example_allow_drift",
            repository="example_repository",
            secret_name="example_secret_name",
            plaintext_value="placeholder")
        ```

        ## Import

        This resource can be imported using an ID made of the repository name, and secret name separated by a `:`.

        > **Note**: When importing secrets, the `plaintext_value` or `encrypted_value` fields will not be populated in the state. You may need to ignore changes for these as a workaround if you're not planning on updating the secret through Terraform.

        ### Import Command

        The following command imports a GitHub Dependabot secret named `mysecret` for the repo `myrepo` to a `DependabotSecret` resource named `example`.

        ```sh
        $ pulumi import github:index/dependabotSecret:DependabotSecret example myrepo:mysecret
        ```

        :param str resource_name: The name of the resource.
        :param DependabotSecretArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(DependabotSecretArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 encrypted_value: Optional[pulumi.Input[_builtins.str]] = None,
                 key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 plaintext_value: Optional[pulumi.Input[_builtins.str]] = None,
                 repository: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = DependabotSecretArgs.__new__(DependabotSecretArgs)

            __props__.__dict__["encrypted_value"] = None if encrypted_value is None else pulumi.Output.secret(encrypted_value)
            __props__.__dict__["key_id"] = key_id
            __props__.__dict__["plaintext_value"] = None if plaintext_value is None else pulumi.Output.secret(plaintext_value)
            if repository is None and not opts.urn:
                raise TypeError("Missing required property 'repository'")
            __props__.__dict__["repository"] = repository
            if secret_name is None and not opts.urn:
                raise TypeError("Missing required property 'secret_name'")
            __props__.__dict__["secret_name"] = secret_name
            __props__.__dict__["created_at"] = None
            __props__.__dict__["remote_updated_at"] = None
            __props__.__dict__["repository_id"] = None
            __props__.__dict__["updated_at"] = None
        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["encryptedValue", "plaintextValue"])
        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
        super(DependabotSecret, __self__).__init__(
            'github:index/dependabotSecret:DependabotSecret',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            created_at: Optional[pulumi.Input[_builtins.str]] = None,
            encrypted_value: Optional[pulumi.Input[_builtins.str]] = None,
            key_id: Optional[pulumi.Input[_builtins.str]] = None,
            plaintext_value: Optional[pulumi.Input[_builtins.str]] = None,
            remote_updated_at: Optional[pulumi.Input[_builtins.str]] = None,
            repository: Optional[pulumi.Input[_builtins.str]] = None,
            repository_id: Optional[pulumi.Input[_builtins.int]] = None,
            secret_name: Optional[pulumi.Input[_builtins.str]] = None,
            updated_at: Optional[pulumi.Input[_builtins.str]] = None) -> 'DependabotSecret':
        """
        Get an existing DependabotSecret resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] created_at: Date the secret was created.
        :param pulumi.Input[_builtins.str] encrypted_value: Encrypted value of the secret using the GitHub public key in Base64 format.
        :param pulumi.Input[_builtins.str] key_id: ID of the public key used to encrypt the secret. This should be provided when setting `encrypted_value`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintext_value`.
        :param pulumi.Input[_builtins.str] plaintext_value: Plaintext value of the secret to be encrypted.
               
               > **Note**: One of either `encrypted_value` or `plaintext_value` must be specified.
        :param pulumi.Input[_builtins.str] remote_updated_at: Date the secret was last updated in GitHub.
        :param pulumi.Input[_builtins.str] repository: Name of the repository.
        :param pulumi.Input[_builtins.int] repository_id: ID of the repository.
        :param pulumi.Input[_builtins.str] secret_name: Name of the secret.
        :param pulumi.Input[_builtins.str] updated_at: Date the secret was last updated by the provider.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _DependabotSecretState.__new__(_DependabotSecretState)

        __props__.__dict__["created_at"] = created_at
        __props__.__dict__["encrypted_value"] = encrypted_value
        __props__.__dict__["key_id"] = key_id
        __props__.__dict__["plaintext_value"] = plaintext_value
        __props__.__dict__["remote_updated_at"] = remote_updated_at
        __props__.__dict__["repository"] = repository
        __props__.__dict__["repository_id"] = repository_id
        __props__.__dict__["secret_name"] = secret_name
        __props__.__dict__["updated_at"] = updated_at
        return DependabotSecret(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[_builtins.str]:
        """
        Date the secret was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="encryptedValue")
    def encrypted_value(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Encrypted value of the secret using the GitHub public key in Base64 format.
        """
        return pulumi.get(self, "encrypted_value")

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Output[_builtins.str]:
        """
        ID of the public key used to encrypt the secret. This should be provided when setting `encrypted_value`; if it isn't then the current public key will be looked up, which could cause a missmatch. This conflicts with `plaintext_value`.
        """
        return pulumi.get(self, "key_id")

    @_builtins.property
    @pulumi.getter(name="plaintextValue")
    def plaintext_value(self) -> pulumi.Output[Optional[_builtins.str]]:
        """
        Plaintext value of the secret to be encrypted.

        > **Note**: One of either `encrypted_value` or `plaintext_value` must be specified.
        """
        return pulumi.get(self, "plaintext_value")

    @_builtins.property
    @pulumi.getter(name="remoteUpdatedAt")
    def remote_updated_at(self) -> pulumi.Output[_builtins.str]:
        """
        Date the secret was last updated in GitHub.
        """
        return pulumi.get(self, "remote_updated_at")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> pulumi.Output[_builtins.str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> pulumi.Output[_builtins.int]:
        """
        ID of the repository.
        """
        return pulumi.get(self, "repository_id")

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> pulumi.Output[_builtins.str]:
        """
        Name of the secret.
        """
        return pulumi.get(self, "secret_name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> pulumi.Output[_builtins.str]:
        """
        Date the secret was last updated by the provider.
        """
        return pulumi.get(self, "updated_at")

