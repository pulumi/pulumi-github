# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ActionsOrganizationPermissionsAllowedActionsConfigArgs',
    'ActionsOrganizationPermissionsAllowedActionsConfigArgsDict',
    'ActionsOrganizationPermissionsEnabledRepositoriesConfigArgs',
    'ActionsOrganizationPermissionsEnabledRepositoriesConfigArgsDict',
    'ActionsRepositoryPermissionsAllowedActionsConfigArgs',
    'ActionsRepositoryPermissionsAllowedActionsConfigArgsDict',
    'BranchProtectionRequiredPullRequestReviewArgs',
    'BranchProtectionRequiredPullRequestReviewArgsDict',
    'BranchProtectionRequiredStatusCheckArgs',
    'BranchProtectionRequiredStatusCheckArgsDict',
    'BranchProtectionRestrictPushArgs',
    'BranchProtectionRestrictPushArgsDict',
    'BranchProtectionV3RequiredPullRequestReviewsArgs',
    'BranchProtectionV3RequiredPullRequestReviewsArgsDict',
    'BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgs',
    'BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgsDict',
    'BranchProtectionV3RequiredStatusChecksArgs',
    'BranchProtectionV3RequiredStatusChecksArgsDict',
    'BranchProtectionV3RestrictionsArgs',
    'BranchProtectionV3RestrictionsArgsDict',
    'EnterpriseActionsPermissionsAllowedActionsConfigArgs',
    'EnterpriseActionsPermissionsAllowedActionsConfigArgsDict',
    'EnterpriseActionsPermissionsEnabledOrganizationsConfigArgs',
    'EnterpriseActionsPermissionsEnabledOrganizationsConfigArgsDict',
    'IssueLabelsLabelArgs',
    'IssueLabelsLabelArgsDict',
    'OrganizationRulesetBypassActorArgs',
    'OrganizationRulesetBypassActorArgsDict',
    'OrganizationRulesetConditionsArgs',
    'OrganizationRulesetConditionsArgsDict',
    'OrganizationRulesetConditionsRefNameArgs',
    'OrganizationRulesetConditionsRefNameArgsDict',
    'OrganizationRulesetConditionsRepositoryNameArgs',
    'OrganizationRulesetConditionsRepositoryNameArgsDict',
    'OrganizationRulesetRulesArgs',
    'OrganizationRulesetRulesArgsDict',
    'OrganizationRulesetRulesBranchNamePatternArgs',
    'OrganizationRulesetRulesBranchNamePatternArgsDict',
    'OrganizationRulesetRulesCommitAuthorEmailPatternArgs',
    'OrganizationRulesetRulesCommitAuthorEmailPatternArgsDict',
    'OrganizationRulesetRulesCommitMessagePatternArgs',
    'OrganizationRulesetRulesCommitMessagePatternArgsDict',
    'OrganizationRulesetRulesCommitterEmailPatternArgs',
    'OrganizationRulesetRulesCommitterEmailPatternArgsDict',
    'OrganizationRulesetRulesPullRequestArgs',
    'OrganizationRulesetRulesPullRequestArgsDict',
    'OrganizationRulesetRulesRequiredCodeScanningArgs',
    'OrganizationRulesetRulesRequiredCodeScanningArgsDict',
    'OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs',
    'OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgsDict',
    'OrganizationRulesetRulesRequiredStatusChecksArgs',
    'OrganizationRulesetRulesRequiredStatusChecksArgsDict',
    'OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgs',
    'OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgsDict',
    'OrganizationRulesetRulesRequiredWorkflowsArgs',
    'OrganizationRulesetRulesRequiredWorkflowsArgsDict',
    'OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgs',
    'OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgsDict',
    'OrganizationRulesetRulesTagNamePatternArgs',
    'OrganizationRulesetRulesTagNamePatternArgsDict',
    'OrganizationWebhookConfigurationArgs',
    'OrganizationWebhookConfigurationArgsDict',
    'ProviderAppAuthArgs',
    'ProviderAppAuthArgsDict',
    'RepositoryCollaboratorsTeamArgs',
    'RepositoryCollaboratorsTeamArgsDict',
    'RepositoryCollaboratorsUserArgs',
    'RepositoryCollaboratorsUserArgsDict',
    'RepositoryEnvironmentDeploymentBranchPolicyArgs',
    'RepositoryEnvironmentDeploymentBranchPolicyArgsDict',
    'RepositoryEnvironmentReviewerArgs',
    'RepositoryEnvironmentReviewerArgsDict',
    'RepositoryPagesArgs',
    'RepositoryPagesArgsDict',
    'RepositoryPagesSourceArgs',
    'RepositoryPagesSourceArgsDict',
    'RepositoryRulesetBypassActorArgs',
    'RepositoryRulesetBypassActorArgsDict',
    'RepositoryRulesetConditionsArgs',
    'RepositoryRulesetConditionsArgsDict',
    'RepositoryRulesetConditionsRefNameArgs',
    'RepositoryRulesetConditionsRefNameArgsDict',
    'RepositoryRulesetRulesArgs',
    'RepositoryRulesetRulesArgsDict',
    'RepositoryRulesetRulesBranchNamePatternArgs',
    'RepositoryRulesetRulesBranchNamePatternArgsDict',
    'RepositoryRulesetRulesCommitAuthorEmailPatternArgs',
    'RepositoryRulesetRulesCommitAuthorEmailPatternArgsDict',
    'RepositoryRulesetRulesCommitMessagePatternArgs',
    'RepositoryRulesetRulesCommitMessagePatternArgsDict',
    'RepositoryRulesetRulesCommitterEmailPatternArgs',
    'RepositoryRulesetRulesCommitterEmailPatternArgsDict',
    'RepositoryRulesetRulesPullRequestArgs',
    'RepositoryRulesetRulesPullRequestArgsDict',
    'RepositoryRulesetRulesRequiredCodeScanningArgs',
    'RepositoryRulesetRulesRequiredCodeScanningArgsDict',
    'RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs',
    'RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgsDict',
    'RepositoryRulesetRulesRequiredDeploymentsArgs',
    'RepositoryRulesetRulesRequiredDeploymentsArgsDict',
    'RepositoryRulesetRulesRequiredStatusChecksArgs',
    'RepositoryRulesetRulesRequiredStatusChecksArgsDict',
    'RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgs',
    'RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgsDict',
    'RepositoryRulesetRulesTagNamePatternArgs',
    'RepositoryRulesetRulesTagNamePatternArgsDict',
    'RepositorySecurityAndAnalysisArgs',
    'RepositorySecurityAndAnalysisArgsDict',
    'RepositorySecurityAndAnalysisAdvancedSecurityArgs',
    'RepositorySecurityAndAnalysisAdvancedSecurityArgsDict',
    'RepositorySecurityAndAnalysisSecretScanningArgs',
    'RepositorySecurityAndAnalysisSecretScanningArgsDict',
    'RepositorySecurityAndAnalysisSecretScanningPushProtectionArgs',
    'RepositorySecurityAndAnalysisSecretScanningPushProtectionArgsDict',
    'RepositoryTemplateArgs',
    'RepositoryTemplateArgsDict',
    'RepositoryWebhookConfigurationArgs',
    'RepositoryWebhookConfigurationArgsDict',
    'TeamMembersMemberArgs',
    'TeamMembersMemberArgsDict',
    'TeamSettingsReviewRequestDelegationArgs',
    'TeamSettingsReviewRequestDelegationArgsDict',
    'TeamSyncGroupMappingGroupArgs',
    'TeamSyncGroupMappingGroupArgsDict',
]

MYPY = False

if not MYPY:
    class ActionsOrganizationPermissionsAllowedActionsConfigArgsDict(TypedDict):
        github_owned_allowed: pulumi.Input[bool]
        """
        Whether GitHub-owned actions are allowed in the organization.
        """
        patterns_alloweds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        """
        verified_allowed: NotRequired[pulumi.Input[bool]]
        """
        Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
elif False:
    ActionsOrganizationPermissionsAllowedActionsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionsOrganizationPermissionsAllowedActionsConfigArgs:
    def __init__(__self__, *,
                 github_owned_allowed: pulumi.Input[bool],
                 patterns_alloweds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verified_allowed: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] github_owned_allowed: Whether GitHub-owned actions are allowed in the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] patterns_alloweds: Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        :param pulumi.Input[bool] verified_allowed: Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
        pulumi.set(__self__, "github_owned_allowed", github_owned_allowed)
        if patterns_alloweds is not None:
            pulumi.set(__self__, "patterns_alloweds", patterns_alloweds)
        if verified_allowed is not None:
            pulumi.set(__self__, "verified_allowed", verified_allowed)

    @property
    @pulumi.getter(name="githubOwnedAllowed")
    def github_owned_allowed(self) -> pulumi.Input[bool]:
        """
        Whether GitHub-owned actions are allowed in the organization.
        """
        return pulumi.get(self, "github_owned_allowed")

    @github_owned_allowed.setter
    def github_owned_allowed(self, value: pulumi.Input[bool]):
        pulumi.set(self, "github_owned_allowed", value)

    @property
    @pulumi.getter(name="patternsAlloweds")
    def patterns_alloweds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        """
        return pulumi.get(self, "patterns_alloweds")

    @patterns_alloweds.setter
    def patterns_alloweds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "patterns_alloweds", value)

    @property
    @pulumi.getter(name="verifiedAllowed")
    def verified_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
        return pulumi.get(self, "verified_allowed")

    @verified_allowed.setter
    def verified_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verified_allowed", value)


if not MYPY:
    class ActionsOrganizationPermissionsEnabledRepositoriesConfigArgsDict(TypedDict):
        repository_ids: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        List of repository IDs to enable for GitHub Actions.
        """
elif False:
    ActionsOrganizationPermissionsEnabledRepositoriesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionsOrganizationPermissionsEnabledRepositoriesConfigArgs:
    def __init__(__self__, *,
                 repository_ids: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] repository_ids: List of repository IDs to enable for GitHub Actions.
        """
        pulumi.set(__self__, "repository_ids", repository_ids)

    @property
    @pulumi.getter(name="repositoryIds")
    def repository_ids(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        List of repository IDs to enable for GitHub Actions.
        """
        return pulumi.get(self, "repository_ids")

    @repository_ids.setter
    def repository_ids(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "repository_ids", value)


if not MYPY:
    class ActionsRepositoryPermissionsAllowedActionsConfigArgsDict(TypedDict):
        github_owned_allowed: pulumi.Input[bool]
        """
        Whether GitHub-owned actions are allowed in the repository.
        """
        patterns_alloweds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        """
        verified_allowed: NotRequired[pulumi.Input[bool]]
        """
        Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
elif False:
    ActionsRepositoryPermissionsAllowedActionsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ActionsRepositoryPermissionsAllowedActionsConfigArgs:
    def __init__(__self__, *,
                 github_owned_allowed: pulumi.Input[bool],
                 patterns_alloweds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verified_allowed: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] github_owned_allowed: Whether GitHub-owned actions are allowed in the repository.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] patterns_alloweds: Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        :param pulumi.Input[bool] verified_allowed: Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
        pulumi.set(__self__, "github_owned_allowed", github_owned_allowed)
        if patterns_alloweds is not None:
            pulumi.set(__self__, "patterns_alloweds", patterns_alloweds)
        if verified_allowed is not None:
            pulumi.set(__self__, "verified_allowed", verified_allowed)

    @property
    @pulumi.getter(name="githubOwnedAllowed")
    def github_owned_allowed(self) -> pulumi.Input[bool]:
        """
        Whether GitHub-owned actions are allowed in the repository.
        """
        return pulumi.get(self, "github_owned_allowed")

    @github_owned_allowed.setter
    def github_owned_allowed(self, value: pulumi.Input[bool]):
        pulumi.set(self, "github_owned_allowed", value)

    @property
    @pulumi.getter(name="patternsAlloweds")
    def patterns_alloweds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        """
        return pulumi.get(self, "patterns_alloweds")

    @patterns_alloweds.setter
    def patterns_alloweds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "patterns_alloweds", value)

    @property
    @pulumi.getter(name="verifiedAllowed")
    def verified_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
        return pulumi.get(self, "verified_allowed")

    @verified_allowed.setter
    def verified_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verified_allowed", value)


if not MYPY:
    class BranchProtectionRequiredPullRequestReviewArgsDict(TypedDict):
        dismiss_stale_reviews: NotRequired[pulumi.Input[bool]]
        """
        Dismiss approved reviews automatically when a new commit is pushed. Defaults to `false`.
        """
        dismissal_restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of actor Names/IDs with dismissal access. If not empty, `restrict_dismissals` is ignored. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams.
        """
        pull_request_bypassers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of actor Names/IDs that are allowed to bypass pull request requirements. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams.
        """
        require_code_owner_reviews: NotRequired[pulumi.Input[bool]]
        """
        Require an approved review in pull requests including files with a designated code owner. Defaults to `false`.
        """
        require_last_push_approval: NotRequired[pulumi.Input[bool]]
        """
        Require that The most recent push must be approved by someone other than the last pusher.  Defaults to `false`
        """
        required_approving_review_count: NotRequired[pulumi.Input[int]]
        """
        Require x number of approvals to satisfy branch protection requirements. If this is specified it must be a number between 0-6. This requirement matches GitHub's API, see the upstream [documentation](https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
        (https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
        """
        restrict_dismissals: NotRequired[pulumi.Input[bool]]
        """
        Restrict pull request review dismissals.
        """
elif False:
    BranchProtectionRequiredPullRequestReviewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionRequiredPullRequestReviewArgs:
    def __init__(__self__, *,
                 dismiss_stale_reviews: Optional[pulumi.Input[bool]] = None,
                 dismissal_restrictions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pull_request_bypassers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 require_code_owner_reviews: Optional[pulumi.Input[bool]] = None,
                 require_last_push_approval: Optional[pulumi.Input[bool]] = None,
                 required_approving_review_count: Optional[pulumi.Input[int]] = None,
                 restrict_dismissals: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] dismiss_stale_reviews: Dismiss approved reviews automatically when a new commit is pushed. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dismissal_restrictions: The list of actor Names/IDs with dismissal access. If not empty, `restrict_dismissals` is ignored. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pull_request_bypassers: The list of actor Names/IDs that are allowed to bypass pull request requirements. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams.
        :param pulumi.Input[bool] require_code_owner_reviews: Require an approved review in pull requests including files with a designated code owner. Defaults to `false`.
        :param pulumi.Input[bool] require_last_push_approval: Require that The most recent push must be approved by someone other than the last pusher.  Defaults to `false`
        :param pulumi.Input[int] required_approving_review_count: Require x number of approvals to satisfy branch protection requirements. If this is specified it must be a number between 0-6. This requirement matches GitHub's API, see the upstream [documentation](https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
               (https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
        :param pulumi.Input[bool] restrict_dismissals: Restrict pull request review dismissals.
        """
        if dismiss_stale_reviews is not None:
            pulumi.set(__self__, "dismiss_stale_reviews", dismiss_stale_reviews)
        if dismissal_restrictions is not None:
            pulumi.set(__self__, "dismissal_restrictions", dismissal_restrictions)
        if pull_request_bypassers is not None:
            pulumi.set(__self__, "pull_request_bypassers", pull_request_bypassers)
        if require_code_owner_reviews is not None:
            pulumi.set(__self__, "require_code_owner_reviews", require_code_owner_reviews)
        if require_last_push_approval is not None:
            pulumi.set(__self__, "require_last_push_approval", require_last_push_approval)
        if required_approving_review_count is not None:
            pulumi.set(__self__, "required_approving_review_count", required_approving_review_count)
        if restrict_dismissals is not None:
            pulumi.set(__self__, "restrict_dismissals", restrict_dismissals)

    @property
    @pulumi.getter(name="dismissStaleReviews")
    def dismiss_stale_reviews(self) -> Optional[pulumi.Input[bool]]:
        """
        Dismiss approved reviews automatically when a new commit is pushed. Defaults to `false`.
        """
        return pulumi.get(self, "dismiss_stale_reviews")

    @dismiss_stale_reviews.setter
    def dismiss_stale_reviews(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dismiss_stale_reviews", value)

    @property
    @pulumi.getter(name="dismissalRestrictions")
    def dismissal_restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of actor Names/IDs with dismissal access. If not empty, `restrict_dismissals` is ignored. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams.
        """
        return pulumi.get(self, "dismissal_restrictions")

    @dismissal_restrictions.setter
    def dismissal_restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dismissal_restrictions", value)

    @property
    @pulumi.getter(name="pullRequestBypassers")
    def pull_request_bypassers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of actor Names/IDs that are allowed to bypass pull request requirements. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams.
        """
        return pulumi.get(self, "pull_request_bypassers")

    @pull_request_bypassers.setter
    def pull_request_bypassers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "pull_request_bypassers", value)

    @property
    @pulumi.getter(name="requireCodeOwnerReviews")
    def require_code_owner_reviews(self) -> Optional[pulumi.Input[bool]]:
        """
        Require an approved review in pull requests including files with a designated code owner. Defaults to `false`.
        """
        return pulumi.get(self, "require_code_owner_reviews")

    @require_code_owner_reviews.setter
    def require_code_owner_reviews(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_code_owner_reviews", value)

    @property
    @pulumi.getter(name="requireLastPushApproval")
    def require_last_push_approval(self) -> Optional[pulumi.Input[bool]]:
        """
        Require that The most recent push must be approved by someone other than the last pusher.  Defaults to `false`
        """
        return pulumi.get(self, "require_last_push_approval")

    @require_last_push_approval.setter
    def require_last_push_approval(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_last_push_approval", value)

    @property
    @pulumi.getter(name="requiredApprovingReviewCount")
    def required_approving_review_count(self) -> Optional[pulumi.Input[int]]:
        """
        Require x number of approvals to satisfy branch protection requirements. If this is specified it must be a number between 0-6. This requirement matches GitHub's API, see the upstream [documentation](https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
        (https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
        """
        return pulumi.get(self, "required_approving_review_count")

    @required_approving_review_count.setter
    def required_approving_review_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_approving_review_count", value)

    @property
    @pulumi.getter(name="restrictDismissals")
    def restrict_dismissals(self) -> Optional[pulumi.Input[bool]]:
        """
        Restrict pull request review dismissals.
        """
        return pulumi.get(self, "restrict_dismissals")

    @restrict_dismissals.setter
    def restrict_dismissals(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restrict_dismissals", value)


if not MYPY:
    class BranchProtectionRequiredStatusCheckArgsDict(TypedDict):
        contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of status checks to require in order to merge into this branch. No status checks are required by default.

        > Note: This attribute can contain multiple string patterns.
        If specified, usual value is the [job name](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname). Otherwise, the [job id](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname) is defaulted to.
        For workflows that use matrixes, append the matrix name to the value using the following pattern `(<matrix_value>[, <matrix_value>])`. Matrixes should be specified based on the order of matrix properties in the workflow file. See GitHub Documentation for more information.
        For workflows that use reusable workflows, the pattern is `<initial_workflow.jobs.job.[name/id]> / <reused-workflow.jobs.job.[name/id]>`. This can extend multiple levels.
        """
        strict: NotRequired[pulumi.Input[bool]]
        """
        Require branches to be up to date before merging. Defaults to `false`.
        """
elif False:
    BranchProtectionRequiredStatusCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionRequiredStatusCheckArgs:
    def __init__(__self__, *,
                 contexts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strict: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contexts: The list of status checks to require in order to merge into this branch. No status checks are required by default.
               
               > Note: This attribute can contain multiple string patterns.
               If specified, usual value is the [job name](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname). Otherwise, the [job id](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname) is defaulted to.
               For workflows that use matrixes, append the matrix name to the value using the following pattern `(<matrix_value>[, <matrix_value>])`. Matrixes should be specified based on the order of matrix properties in the workflow file. See GitHub Documentation for more information.
               For workflows that use reusable workflows, the pattern is `<initial_workflow.jobs.job.[name/id]> / <reused-workflow.jobs.job.[name/id]>`. This can extend multiple levels.
        :param pulumi.Input[bool] strict: Require branches to be up to date before merging. Defaults to `false`.
        """
        if contexts is not None:
            pulumi.set(__self__, "contexts", contexts)
        if strict is not None:
            pulumi.set(__self__, "strict", strict)

    @property
    @pulumi.getter
    def contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of status checks to require in order to merge into this branch. No status checks are required by default.

        > Note: This attribute can contain multiple string patterns.
        If specified, usual value is the [job name](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname). Otherwise, the [job id](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname) is defaulted to.
        For workflows that use matrixes, append the matrix name to the value using the following pattern `(<matrix_value>[, <matrix_value>])`. Matrixes should be specified based on the order of matrix properties in the workflow file. See GitHub Documentation for more information.
        For workflows that use reusable workflows, the pattern is `<initial_workflow.jobs.job.[name/id]> / <reused-workflow.jobs.job.[name/id]>`. This can extend multiple levels.
        """
        return pulumi.get(self, "contexts")

    @contexts.setter
    def contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "contexts", value)

    @property
    @pulumi.getter
    def strict(self) -> Optional[pulumi.Input[bool]]:
        """
        Require branches to be up to date before merging. Defaults to `false`.
        """
        return pulumi.get(self, "strict")

    @strict.setter
    def strict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict", value)


if not MYPY:
    class BranchProtectionRestrictPushArgsDict(TypedDict):
        blocks_creations: NotRequired[pulumi.Input[bool]]
        """
        Boolean, setting this to `false` allows people, teams, or apps to create new branches matching this rule. Defaults to `true`.
        """
        push_allowances: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of actor Names/IDs that may push to the branch. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams. Organization administrators, repository administrators, and users with the Maintain role on the repository can always push when all other requirements have passed.
        """
elif False:
    BranchProtectionRestrictPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionRestrictPushArgs:
    def __init__(__self__, *,
                 blocks_creations: Optional[pulumi.Input[bool]] = None,
                 push_allowances: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] blocks_creations: Boolean, setting this to `false` allows people, teams, or apps to create new branches matching this rule. Defaults to `true`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] push_allowances: A list of actor Names/IDs that may push to the branch. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams. Organization administrators, repository administrators, and users with the Maintain role on the repository can always push when all other requirements have passed.
        """
        if blocks_creations is not None:
            pulumi.set(__self__, "blocks_creations", blocks_creations)
        if push_allowances is not None:
            pulumi.set(__self__, "push_allowances", push_allowances)

    @property
    @pulumi.getter(name="blocksCreations")
    def blocks_creations(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean, setting this to `false` allows people, teams, or apps to create new branches matching this rule. Defaults to `true`.
        """
        return pulumi.get(self, "blocks_creations")

    @blocks_creations.setter
    def blocks_creations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "blocks_creations", value)

    @property
    @pulumi.getter(name="pushAllowances")
    def push_allowances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of actor Names/IDs that may push to the branch. Actor names must either begin with a "/" for users or the organization name followed by a "/" for teams. Organization administrators, repository administrators, and users with the Maintain role on the repository can always push when all other requirements have passed.
        """
        return pulumi.get(self, "push_allowances")

    @push_allowances.setter
    def push_allowances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "push_allowances", value)


if not MYPY:
    class BranchProtectionV3RequiredPullRequestReviewsArgsDict(TypedDict):
        bypass_pull_request_allowances: NotRequired[pulumi.Input['BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgsDict']]
        """
        Allow specific users, teams, or apps to bypass pull request requirements. See Bypass Pull Request Allowances below for details.
        """
        dismiss_stale_reviews: NotRequired[pulumi.Input[bool]]
        """
        Dismiss approved reviews automatically when a new commit is pushed. Defaults to `false`.
        """
        dismissal_apps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of app slugs with dismissal access.
        """
        dismissal_teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of team slugs with dismissal access.
        Always use `slug` of the team, **not** its name. Each team already **has** to have access to the repository.
        """
        dismissal_users: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of user logins with dismissal access
        """
        include_admins: NotRequired[pulumi.Input[bool]]
        require_code_owner_reviews: NotRequired[pulumi.Input[bool]]
        """
        Require an approved review in pull requests including files with a designated code owner. Defaults to `false`.
        """
        require_last_push_approval: NotRequired[pulumi.Input[bool]]
        """
        Require that the most recent push must be approved by someone other than the last pusher.  Defaults to `false`
        """
        required_approving_review_count: NotRequired[pulumi.Input[int]]
        """
        Require x number of approvals to satisfy branch protection requirements. If this is specified it must be a number between 0-6. This requirement matches GitHub's API, see the upstream [documentation](https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
        """
elif False:
    BranchProtectionV3RequiredPullRequestReviewsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionV3RequiredPullRequestReviewsArgs:
    def __init__(__self__, *,
                 bypass_pull_request_allowances: Optional[pulumi.Input['BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgs']] = None,
                 dismiss_stale_reviews: Optional[pulumi.Input[bool]] = None,
                 dismissal_apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dismissal_teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dismissal_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_admins: Optional[pulumi.Input[bool]] = None,
                 require_code_owner_reviews: Optional[pulumi.Input[bool]] = None,
                 require_last_push_approval: Optional[pulumi.Input[bool]] = None,
                 required_approving_review_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgs'] bypass_pull_request_allowances: Allow specific users, teams, or apps to bypass pull request requirements. See Bypass Pull Request Allowances below for details.
        :param pulumi.Input[bool] dismiss_stale_reviews: Dismiss approved reviews automatically when a new commit is pushed. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dismissal_apps: The list of app slugs with dismissal access.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dismissal_teams: The list of team slugs with dismissal access.
               Always use `slug` of the team, **not** its name. Each team already **has** to have access to the repository.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dismissal_users: The list of user logins with dismissal access
        :param pulumi.Input[bool] require_code_owner_reviews: Require an approved review in pull requests including files with a designated code owner. Defaults to `false`.
        :param pulumi.Input[bool] require_last_push_approval: Require that the most recent push must be approved by someone other than the last pusher.  Defaults to `false`
        :param pulumi.Input[int] required_approving_review_count: Require x number of approvals to satisfy branch protection requirements. If this is specified it must be a number between 0-6. This requirement matches GitHub's API, see the upstream [documentation](https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
        """
        if bypass_pull_request_allowances is not None:
            pulumi.set(__self__, "bypass_pull_request_allowances", bypass_pull_request_allowances)
        if dismiss_stale_reviews is not None:
            pulumi.set(__self__, "dismiss_stale_reviews", dismiss_stale_reviews)
        if dismissal_apps is not None:
            pulumi.set(__self__, "dismissal_apps", dismissal_apps)
        if dismissal_teams is not None:
            pulumi.set(__self__, "dismissal_teams", dismissal_teams)
        if dismissal_users is not None:
            pulumi.set(__self__, "dismissal_users", dismissal_users)
        if include_admins is not None:
            warnings.warn("""Use enforce_admins instead""", DeprecationWarning)
            pulumi.log.warn("""include_admins is deprecated: Use enforce_admins instead""")
        if include_admins is not None:
            pulumi.set(__self__, "include_admins", include_admins)
        if require_code_owner_reviews is not None:
            pulumi.set(__self__, "require_code_owner_reviews", require_code_owner_reviews)
        if require_last_push_approval is not None:
            pulumi.set(__self__, "require_last_push_approval", require_last_push_approval)
        if required_approving_review_count is not None:
            pulumi.set(__self__, "required_approving_review_count", required_approving_review_count)

    @property
    @pulumi.getter(name="bypassPullRequestAllowances")
    def bypass_pull_request_allowances(self) -> Optional[pulumi.Input['BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgs']]:
        """
        Allow specific users, teams, or apps to bypass pull request requirements. See Bypass Pull Request Allowances below for details.
        """
        return pulumi.get(self, "bypass_pull_request_allowances")

    @bypass_pull_request_allowances.setter
    def bypass_pull_request_allowances(self, value: Optional[pulumi.Input['BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgs']]):
        pulumi.set(self, "bypass_pull_request_allowances", value)

    @property
    @pulumi.getter(name="dismissStaleReviews")
    def dismiss_stale_reviews(self) -> Optional[pulumi.Input[bool]]:
        """
        Dismiss approved reviews automatically when a new commit is pushed. Defaults to `false`.
        """
        return pulumi.get(self, "dismiss_stale_reviews")

    @dismiss_stale_reviews.setter
    def dismiss_stale_reviews(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dismiss_stale_reviews", value)

    @property
    @pulumi.getter(name="dismissalApps")
    def dismissal_apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of app slugs with dismissal access.
        """
        return pulumi.get(self, "dismissal_apps")

    @dismissal_apps.setter
    def dismissal_apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dismissal_apps", value)

    @property
    @pulumi.getter(name="dismissalTeams")
    def dismissal_teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of team slugs with dismissal access.
        Always use `slug` of the team, **not** its name. Each team already **has** to have access to the repository.
        """
        return pulumi.get(self, "dismissal_teams")

    @dismissal_teams.setter
    def dismissal_teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dismissal_teams", value)

    @property
    @pulumi.getter(name="dismissalUsers")
    def dismissal_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user logins with dismissal access
        """
        return pulumi.get(self, "dismissal_users")

    @dismissal_users.setter
    def dismissal_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dismissal_users", value)

    @property
    @pulumi.getter(name="includeAdmins")
    @_utilities.deprecated("""Use enforce_admins instead""")
    def include_admins(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_admins")

    @include_admins.setter
    def include_admins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_admins", value)

    @property
    @pulumi.getter(name="requireCodeOwnerReviews")
    def require_code_owner_reviews(self) -> Optional[pulumi.Input[bool]]:
        """
        Require an approved review in pull requests including files with a designated code owner. Defaults to `false`.
        """
        return pulumi.get(self, "require_code_owner_reviews")

    @require_code_owner_reviews.setter
    def require_code_owner_reviews(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_code_owner_reviews", value)

    @property
    @pulumi.getter(name="requireLastPushApproval")
    def require_last_push_approval(self) -> Optional[pulumi.Input[bool]]:
        """
        Require that the most recent push must be approved by someone other than the last pusher.  Defaults to `false`
        """
        return pulumi.get(self, "require_last_push_approval")

    @require_last_push_approval.setter
    def require_last_push_approval(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_last_push_approval", value)

    @property
    @pulumi.getter(name="requiredApprovingReviewCount")
    def required_approving_review_count(self) -> Optional[pulumi.Input[int]]:
        """
        Require x number of approvals to satisfy branch protection requirements. If this is specified it must be a number between 0-6. This requirement matches GitHub's API, see the upstream [documentation](https://developer.github.com/v3/repos/branches/#parameters-1) for more information.
        """
        return pulumi.get(self, "required_approving_review_count")

    @required_approving_review_count.setter
    def required_approving_review_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_approving_review_count", value)


if not MYPY:
    class BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgsDict(TypedDict):
        apps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of app slugs allowed to bypass pull request requirements.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of team slugs allowed to bypass pull request requirements.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of user logins allowed to bypass pull request requirements.
        """
elif False:
    BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionV3RequiredPullRequestReviewsBypassPullRequestAllowancesArgs:
    def __init__(__self__, *,
                 apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] apps: The list of app slugs allowed to bypass pull request requirements.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The list of team slugs allowed to bypass pull request requirements.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] users: The list of user logins allowed to bypass pull request requirements.
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of app slugs allowed to bypass pull request requirements.
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of team slugs allowed to bypass pull request requirements.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user logins allowed to bypass pull request requirements.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class BranchProtectionV3RequiredStatusChecksArgsDict(TypedDict):
        checks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of status checks to require in order to merge into this branch. No status checks are required by default. Checks should be strings containing the context and app_id like so "context:app_id".
        """
        contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        [**DEPRECATED**] (Optional) The list of status checks to require in order to merge into this branch. No status checks are required by default.

        > Note: This attribute can contain multiple string patterns.
        If specified, usual value is the [job name](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname). Otherwise, the [job id](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname) is defaulted to.
        For workflows that use matrixes, append the matrix name to the value using the following pattern `(<matrix_value>[, <matrix_value>])`. Matrixes should be specified based on the order of matrix properties in the workflow file. See GitHub Documentation for more information.
        For workflows that use reusable workflows, the pattern is `<initial_workflow.jobs.job.[name/id]> / <reused-workflow.jobs.job.[name/id]>`. This can extend multiple levels.
        """
        include_admins: NotRequired[pulumi.Input[bool]]
        strict: NotRequired[pulumi.Input[bool]]
        """
        Require branches to be up to date before merging. Defaults to `false`.
        """
elif False:
    BranchProtectionV3RequiredStatusChecksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionV3RequiredStatusChecksArgs:
    def __init__(__self__, *,
                 checks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 contexts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_admins: Optional[pulumi.Input[bool]] = None,
                 strict: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] checks: The list of status checks to require in order to merge into this branch. No status checks are required by default. Checks should be strings containing the context and app_id like so "context:app_id".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] contexts: [**DEPRECATED**] (Optional) The list of status checks to require in order to merge into this branch. No status checks are required by default.
               
               > Note: This attribute can contain multiple string patterns.
               If specified, usual value is the [job name](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname). Otherwise, the [job id](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname) is defaulted to.
               For workflows that use matrixes, append the matrix name to the value using the following pattern `(<matrix_value>[, <matrix_value>])`. Matrixes should be specified based on the order of matrix properties in the workflow file. See GitHub Documentation for more information.
               For workflows that use reusable workflows, the pattern is `<initial_workflow.jobs.job.[name/id]> / <reused-workflow.jobs.job.[name/id]>`. This can extend multiple levels.
        :param pulumi.Input[bool] strict: Require branches to be up to date before merging. Defaults to `false`.
        """
        if checks is not None:
            pulumi.set(__self__, "checks", checks)
        if contexts is not None:
            warnings.warn("""GitHub is deprecating the use of `contexts`. Use a `checks` array instead.""", DeprecationWarning)
            pulumi.log.warn("""contexts is deprecated: GitHub is deprecating the use of `contexts`. Use a `checks` array instead.""")
        if contexts is not None:
            pulumi.set(__self__, "contexts", contexts)
        if include_admins is not None:
            warnings.warn("""Use enforce_admins instead""", DeprecationWarning)
            pulumi.log.warn("""include_admins is deprecated: Use enforce_admins instead""")
        if include_admins is not None:
            pulumi.set(__self__, "include_admins", include_admins)
        if strict is not None:
            pulumi.set(__self__, "strict", strict)

    @property
    @pulumi.getter
    def checks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of status checks to require in order to merge into this branch. No status checks are required by default. Checks should be strings containing the context and app_id like so "context:app_id".
        """
        return pulumi.get(self, "checks")

    @checks.setter
    def checks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "checks", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""GitHub is deprecating the use of `contexts`. Use a `checks` array instead.""")
    def contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        [**DEPRECATED**] (Optional) The list of status checks to require in order to merge into this branch. No status checks are required by default.

        > Note: This attribute can contain multiple string patterns.
        If specified, usual value is the [job name](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname). Otherwise, the [job id](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname) is defaulted to.
        For workflows that use matrixes, append the matrix name to the value using the following pattern `(<matrix_value>[, <matrix_value>])`. Matrixes should be specified based on the order of matrix properties in the workflow file. See GitHub Documentation for more information.
        For workflows that use reusable workflows, the pattern is `<initial_workflow.jobs.job.[name/id]> / <reused-workflow.jobs.job.[name/id]>`. This can extend multiple levels.
        """
        return pulumi.get(self, "contexts")

    @contexts.setter
    def contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "contexts", value)

    @property
    @pulumi.getter(name="includeAdmins")
    @_utilities.deprecated("""Use enforce_admins instead""")
    def include_admins(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_admins")

    @include_admins.setter
    def include_admins(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_admins", value)

    @property
    @pulumi.getter
    def strict(self) -> Optional[pulumi.Input[bool]]:
        """
        Require branches to be up to date before merging. Defaults to `false`.
        """
        return pulumi.get(self, "strict")

    @strict.setter
    def strict(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict", value)


if not MYPY:
    class BranchProtectionV3RestrictionsArgsDict(TypedDict):
        apps: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of app slugs with push access.

        `restrictions` is only available for organization-owned repositories.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of team slugs with push access.
        Always use `slug` of the team, **not** its name. Each team already **has** to have access to the repository.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of user logins with push access.
        """
elif False:
    BranchProtectionV3RestrictionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BranchProtectionV3RestrictionsArgs:
    def __init__(__self__, *,
                 apps: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] apps: The list of app slugs with push access.
               
               `restrictions` is only available for organization-owned repositories.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: The list of team slugs with push access.
               Always use `slug` of the team, **not** its name. Each team already **has** to have access to the repository.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] users: The list of user logins with push access.
        """
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of app slugs with push access.

        `restrictions` is only available for organization-owned repositories.
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "apps", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of team slugs with push access.
        Always use `slug` of the team, **not** its name. Each team already **has** to have access to the repository.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "teams", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of user logins with push access.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class EnterpriseActionsPermissionsAllowedActionsConfigArgsDict(TypedDict):
        github_owned_allowed: pulumi.Input[bool]
        """
        Whether GitHub-owned actions are allowed in the organization.
        """
        patterns_alloweds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        """
        verified_allowed: NotRequired[pulumi.Input[bool]]
        """
        Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
elif False:
    EnterpriseActionsPermissionsAllowedActionsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseActionsPermissionsAllowedActionsConfigArgs:
    def __init__(__self__, *,
                 github_owned_allowed: pulumi.Input[bool],
                 patterns_alloweds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verified_allowed: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] github_owned_allowed: Whether GitHub-owned actions are allowed in the organization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] patterns_alloweds: Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        :param pulumi.Input[bool] verified_allowed: Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
        pulumi.set(__self__, "github_owned_allowed", github_owned_allowed)
        if patterns_alloweds is not None:
            pulumi.set(__self__, "patterns_alloweds", patterns_alloweds)
        if verified_allowed is not None:
            pulumi.set(__self__, "verified_allowed", verified_allowed)

    @property
    @pulumi.getter(name="githubOwnedAllowed")
    def github_owned_allowed(self) -> pulumi.Input[bool]:
        """
        Whether GitHub-owned actions are allowed in the organization.
        """
        return pulumi.get(self, "github_owned_allowed")

    @github_owned_allowed.setter
    def github_owned_allowed(self, value: pulumi.Input[bool]):
        pulumi.set(self, "github_owned_allowed", value)

    @property
    @pulumi.getter(name="patternsAlloweds")
    def patterns_alloweds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, monalisa/octocat@*, monalisa/octocat@v2, monalisa/*."
        """
        return pulumi.get(self, "patterns_alloweds")

    @patterns_alloweds.setter
    def patterns_alloweds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "patterns_alloweds", value)

    @property
    @pulumi.getter(name="verifiedAllowed")
    def verified_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether actions in GitHub Marketplace from verified creators are allowed. Set to true to allow all GitHub Marketplace actions by verified creators.
        """
        return pulumi.get(self, "verified_allowed")

    @verified_allowed.setter
    def verified_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verified_allowed", value)


if not MYPY:
    class EnterpriseActionsPermissionsEnabledOrganizationsConfigArgsDict(TypedDict):
        organization_ids: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        List of organization IDs to enable for GitHub Actions.
        """
elif False:
    EnterpriseActionsPermissionsEnabledOrganizationsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnterpriseActionsPermissionsEnabledOrganizationsConfigArgs:
    def __init__(__self__, *,
                 organization_ids: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] organization_ids: List of organization IDs to enable for GitHub Actions.
        """
        pulumi.set(__self__, "organization_ids", organization_ids)

    @property
    @pulumi.getter(name="organizationIds")
    def organization_ids(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        List of organization IDs to enable for GitHub Actions.
        """
        return pulumi.get(self, "organization_ids")

    @organization_ids.setter
    def organization_ids(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "organization_ids", value)


if not MYPY:
    class IssueLabelsLabelArgsDict(TypedDict):
        color: pulumi.Input[str]
        """
        A 6 character hex code, **without the leading #**, identifying the color of the label.
        """
        name: pulumi.Input[str]
        """
        The name of the label.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A short description of the label.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The URL to the issue label
        """
elif False:
    IssueLabelsLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IssueLabelsLabelArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] color: A 6 character hex code, **without the leading #**, identifying the color of the label.
        :param pulumi.Input[str] name: The name of the label.
        :param pulumi.Input[str] description: A short description of the label.
        :param pulumi.Input[str] url: The URL to the issue label
        """
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        """
        A 6 character hex code, **without the leading #**, identifying the color of the label.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the label.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the label.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to the issue label
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class OrganizationRulesetBypassActorArgsDict(TypedDict):
        actor_id: pulumi.Input[int]
        """
        (Number) The ID of the actor that can bypass a ruleset.
        """
        actor_type: pulumi.Input[str]
        """
        The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
        """
        bypass_mode: pulumi.Input[str]
        """
        (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.

        ~>Note: at the time of writing this, the following actor types correspond to the following actor IDs:

        * `OrganizationAdmin` > `1`
        * `RepositoryRole` (This is the actor type, the following are the base repository roles and their associated IDs.)
        """
elif False:
    OrganizationRulesetBypassActorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetBypassActorArgs:
    def __init__(__self__, *,
                 actor_id: pulumi.Input[int],
                 actor_type: pulumi.Input[str],
                 bypass_mode: pulumi.Input[str]):
        """
        :param pulumi.Input[int] actor_id: (Number) The ID of the actor that can bypass a ruleset.
        :param pulumi.Input[str] actor_type: The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
        :param pulumi.Input[str] bypass_mode: (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
               
               ~>Note: at the time of writing this, the following actor types correspond to the following actor IDs:
               
               * `OrganizationAdmin` > `1`
               * `RepositoryRole` (This is the actor type, the following are the base repository roles and their associated IDs.)
        """
        pulumi.set(__self__, "actor_id", actor_id)
        pulumi.set(__self__, "actor_type", actor_type)
        pulumi.set(__self__, "bypass_mode", bypass_mode)

    @property
    @pulumi.getter(name="actorId")
    def actor_id(self) -> pulumi.Input[int]:
        """
        (Number) The ID of the actor that can bypass a ruleset.
        """
        return pulumi.get(self, "actor_id")

    @actor_id.setter
    def actor_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "actor_id", value)

    @property
    @pulumi.getter(name="actorType")
    def actor_type(self) -> pulumi.Input[str]:
        """
        The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
        """
        return pulumi.get(self, "actor_type")

    @actor_type.setter
    def actor_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "actor_type", value)

    @property
    @pulumi.getter(name="bypassMode")
    def bypass_mode(self) -> pulumi.Input[str]:
        """
        (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.

        ~>Note: at the time of writing this, the following actor types correspond to the following actor IDs:

        * `OrganizationAdmin` > `1`
        * `RepositoryRole` (This is the actor type, the following are the base repository roles and their associated IDs.)
        """
        return pulumi.get(self, "bypass_mode")

    @bypass_mode.setter
    def bypass_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "bypass_mode", value)


if not MYPY:
    class OrganizationRulesetConditionsArgsDict(TypedDict):
        ref_name: pulumi.Input['OrganizationRulesetConditionsRefNameArgsDict']
        """
        (Block List, Min: 1, Max: 1) (see below for nested schema)
        """
        repository_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass. Conflicts with `repository_name`.
        """
        repository_name: NotRequired[pulumi.Input['OrganizationRulesetConditionsRepositoryNameArgsDict']]
        """
        Conflicts with `repository_id`. (see below for nested schema)

        One of `repository_id` and `repository_name` must be set for the rule to target any repositories.
        """
elif False:
    OrganizationRulesetConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetConditionsArgs:
    def __init__(__self__, *,
                 ref_name: pulumi.Input['OrganizationRulesetConditionsRefNameArgs'],
                 repository_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 repository_name: Optional[pulumi.Input['OrganizationRulesetConditionsRepositoryNameArgs']] = None):
        """
        :param pulumi.Input['OrganizationRulesetConditionsRefNameArgs'] ref_name: (Block List, Min: 1, Max: 1) (see below for nested schema)
        :param pulumi.Input[Sequence[pulumi.Input[int]]] repository_ids: The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass. Conflicts with `repository_name`.
        :param pulumi.Input['OrganizationRulesetConditionsRepositoryNameArgs'] repository_name: Conflicts with `repository_id`. (see below for nested schema)
               
               One of `repository_id` and `repository_name` must be set for the rule to target any repositories.
        """
        pulumi.set(__self__, "ref_name", ref_name)
        if repository_ids is not None:
            pulumi.set(__self__, "repository_ids", repository_ids)
        if repository_name is not None:
            pulumi.set(__self__, "repository_name", repository_name)

    @property
    @pulumi.getter(name="refName")
    def ref_name(self) -> pulumi.Input['OrganizationRulesetConditionsRefNameArgs']:
        """
        (Block List, Min: 1, Max: 1) (see below for nested schema)
        """
        return pulumi.get(self, "ref_name")

    @ref_name.setter
    def ref_name(self, value: pulumi.Input['OrganizationRulesetConditionsRefNameArgs']):
        pulumi.set(self, "ref_name", value)

    @property
    @pulumi.getter(name="repositoryIds")
    def repository_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass. Conflicts with `repository_name`.
        """
        return pulumi.get(self, "repository_ids")

    @repository_ids.setter
    def repository_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "repository_ids", value)

    @property
    @pulumi.getter(name="repositoryName")
    def repository_name(self) -> Optional[pulumi.Input['OrganizationRulesetConditionsRepositoryNameArgs']]:
        """
        Conflicts with `repository_id`. (see below for nested schema)

        One of `repository_id` and `repository_name` must be set for the rule to target any repositories.
        """
        return pulumi.get(self, "repository_name")

    @repository_name.setter
    def repository_name(self, value: Optional[pulumi.Input['OrganizationRulesetConditionsRepositoryNameArgs']]):
        pulumi.set(self, "repository_name", value)


if not MYPY:
    class OrganizationRulesetConditionsRefNameArgsDict(TypedDict):
        excludes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
        """
        includes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
        """
elif False:
    OrganizationRulesetConditionsRefNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetConditionsRefNameArgs:
    def __init__(__self__, *,
                 excludes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 includes: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
        """
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class OrganizationRulesetConditionsRepositoryNameArgsDict(TypedDict):
        excludes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
        """
        includes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
        """
        protected: NotRequired[pulumi.Input[bool]]
        """
        Whether renaming of target repositories is prevented.
        """
elif False:
    OrganizationRulesetConditionsRepositoryNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetConditionsRepositoryNameArgs:
    def __init__(__self__, *,
                 excludes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 includes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 protected: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
        :param pulumi.Input[bool] protected: Whether renaming of target repositories is prevented.
        """
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "includes", includes)
        if protected is not None:
            pulumi.set(__self__, "protected", protected)

    @property
    @pulumi.getter
    def excludes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "includes", value)

    @property
    @pulumi.getter
    def protected(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether renaming of target repositories is prevented.
        """
        return pulumi.get(self, "protected")

    @protected.setter
    def protected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "protected", value)


if not MYPY:
    class OrganizationRulesetRulesArgsDict(TypedDict):
        branch_name_pattern: NotRequired[pulumi.Input['OrganizationRulesetRulesBranchNamePatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`. (see below for nested schema)
        """
        commit_author_email_pattern: NotRequired[pulumi.Input['OrganizationRulesetRulesCommitAuthorEmailPatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        commit_message_pattern: NotRequired[pulumi.Input['OrganizationRulesetRulesCommitMessagePatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        committer_email_pattern: NotRequired[pulumi.Input['OrganizationRulesetRulesCommitterEmailPatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        creation: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Only allow users with bypass permission to create matching refs.
        """
        deletion: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Only allow users with bypass permissions to delete matching refs.
        """
        non_fast_forward: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Prevent users with push access from force pushing to branches.
        """
        pull_request: NotRequired[pulumi.Input['OrganizationRulesetRulesPullRequestArgsDict']]
        """
        (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
        """
        required_code_scanning: NotRequired[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningArgsDict']]
        """
        (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
        """
        required_linear_history: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Prevent merge commits from being pushed to matching branches.
        """
        required_signatures: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Commits pushed to matching branches must have verified signatures.
        """
        required_status_checks: NotRequired[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksArgsDict']]
        """
        (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
        """
        required_workflows: NotRequired[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsArgsDict']]
        """
        (Block List, Max: 1) Define which Actions workflows must pass before changes can be merged into a branch matching the rule. Multiple workflows can be specified. (see below for nested schema)
        """
        tag_name_pattern: NotRequired[pulumi.Input['OrganizationRulesetRulesTagNamePatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`. (see below for nested schema)
        """
        update: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Only allow users with bypass permission to update matching refs.
        """
elif False:
    OrganizationRulesetRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesArgs:
    def __init__(__self__, *,
                 branch_name_pattern: Optional[pulumi.Input['OrganizationRulesetRulesBranchNamePatternArgs']] = None,
                 commit_author_email_pattern: Optional[pulumi.Input['OrganizationRulesetRulesCommitAuthorEmailPatternArgs']] = None,
                 commit_message_pattern: Optional[pulumi.Input['OrganizationRulesetRulesCommitMessagePatternArgs']] = None,
                 committer_email_pattern: Optional[pulumi.Input['OrganizationRulesetRulesCommitterEmailPatternArgs']] = None,
                 creation: Optional[pulumi.Input[bool]] = None,
                 deletion: Optional[pulumi.Input[bool]] = None,
                 non_fast_forward: Optional[pulumi.Input[bool]] = None,
                 pull_request: Optional[pulumi.Input['OrganizationRulesetRulesPullRequestArgs']] = None,
                 required_code_scanning: Optional[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningArgs']] = None,
                 required_linear_history: Optional[pulumi.Input[bool]] = None,
                 required_signatures: Optional[pulumi.Input[bool]] = None,
                 required_status_checks: Optional[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksArgs']] = None,
                 required_workflows: Optional[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsArgs']] = None,
                 tag_name_pattern: Optional[pulumi.Input['OrganizationRulesetRulesTagNamePatternArgs']] = None,
                 update: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['OrganizationRulesetRulesBranchNamePatternArgs'] branch_name_pattern: (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`. (see below for nested schema)
        :param pulumi.Input['OrganizationRulesetRulesCommitAuthorEmailPatternArgs'] commit_author_email_pattern: (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        :param pulumi.Input['OrganizationRulesetRulesCommitMessagePatternArgs'] commit_message_pattern: (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        :param pulumi.Input['OrganizationRulesetRulesCommitterEmailPatternArgs'] committer_email_pattern: (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        :param pulumi.Input[bool] creation: (Boolean) Only allow users with bypass permission to create matching refs.
        :param pulumi.Input[bool] deletion: (Boolean) Only allow users with bypass permissions to delete matching refs.
        :param pulumi.Input[bool] non_fast_forward: (Boolean) Prevent users with push access from force pushing to branches.
        :param pulumi.Input['OrganizationRulesetRulesPullRequestArgs'] pull_request: (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
        :param pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningArgs'] required_code_scanning: (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
        :param pulumi.Input[bool] required_linear_history: (Boolean) Prevent merge commits from being pushed to matching branches.
        :param pulumi.Input[bool] required_signatures: (Boolean) Commits pushed to matching branches must have verified signatures.
        :param pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksArgs'] required_status_checks: (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
        :param pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsArgs'] required_workflows: (Block List, Max: 1) Define which Actions workflows must pass before changes can be merged into a branch matching the rule. Multiple workflows can be specified. (see below for nested schema)
        :param pulumi.Input['OrganizationRulesetRulesTagNamePatternArgs'] tag_name_pattern: (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`. (see below for nested schema)
        :param pulumi.Input[bool] update: (Boolean) Only allow users with bypass permission to update matching refs.
        """
        if branch_name_pattern is not None:
            pulumi.set(__self__, "branch_name_pattern", branch_name_pattern)
        if commit_author_email_pattern is not None:
            pulumi.set(__self__, "commit_author_email_pattern", commit_author_email_pattern)
        if commit_message_pattern is not None:
            pulumi.set(__self__, "commit_message_pattern", commit_message_pattern)
        if committer_email_pattern is not None:
            pulumi.set(__self__, "committer_email_pattern", committer_email_pattern)
        if creation is not None:
            pulumi.set(__self__, "creation", creation)
        if deletion is not None:
            pulumi.set(__self__, "deletion", deletion)
        if non_fast_forward is not None:
            pulumi.set(__self__, "non_fast_forward", non_fast_forward)
        if pull_request is not None:
            pulumi.set(__self__, "pull_request", pull_request)
        if required_code_scanning is not None:
            pulumi.set(__self__, "required_code_scanning", required_code_scanning)
        if required_linear_history is not None:
            pulumi.set(__self__, "required_linear_history", required_linear_history)
        if required_signatures is not None:
            pulumi.set(__self__, "required_signatures", required_signatures)
        if required_status_checks is not None:
            pulumi.set(__self__, "required_status_checks", required_status_checks)
        if required_workflows is not None:
            pulumi.set(__self__, "required_workflows", required_workflows)
        if tag_name_pattern is not None:
            pulumi.set(__self__, "tag_name_pattern", tag_name_pattern)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter(name="branchNamePattern")
    def branch_name_pattern(self) -> Optional[pulumi.Input['OrganizationRulesetRulesBranchNamePatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`. (see below for nested schema)
        """
        return pulumi.get(self, "branch_name_pattern")

    @branch_name_pattern.setter
    def branch_name_pattern(self, value: Optional[pulumi.Input['OrganizationRulesetRulesBranchNamePatternArgs']]):
        pulumi.set(self, "branch_name_pattern", value)

    @property
    @pulumi.getter(name="commitAuthorEmailPattern")
    def commit_author_email_pattern(self) -> Optional[pulumi.Input['OrganizationRulesetRulesCommitAuthorEmailPatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        return pulumi.get(self, "commit_author_email_pattern")

    @commit_author_email_pattern.setter
    def commit_author_email_pattern(self, value: Optional[pulumi.Input['OrganizationRulesetRulesCommitAuthorEmailPatternArgs']]):
        pulumi.set(self, "commit_author_email_pattern", value)

    @property
    @pulumi.getter(name="commitMessagePattern")
    def commit_message_pattern(self) -> Optional[pulumi.Input['OrganizationRulesetRulesCommitMessagePatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        return pulumi.get(self, "commit_message_pattern")

    @commit_message_pattern.setter
    def commit_message_pattern(self, value: Optional[pulumi.Input['OrganizationRulesetRulesCommitMessagePatternArgs']]):
        pulumi.set(self, "commit_message_pattern", value)

    @property
    @pulumi.getter(name="committerEmailPattern")
    def committer_email_pattern(self) -> Optional[pulumi.Input['OrganizationRulesetRulesCommitterEmailPatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        return pulumi.get(self, "committer_email_pattern")

    @committer_email_pattern.setter
    def committer_email_pattern(self, value: Optional[pulumi.Input['OrganizationRulesetRulesCommitterEmailPatternArgs']]):
        pulumi.set(self, "committer_email_pattern", value)

    @property
    @pulumi.getter
    def creation(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Only allow users with bypass permission to create matching refs.
        """
        return pulumi.get(self, "creation")

    @creation.setter
    def creation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "creation", value)

    @property
    @pulumi.getter
    def deletion(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Only allow users with bypass permissions to delete matching refs.
        """
        return pulumi.get(self, "deletion")

    @deletion.setter
    def deletion(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deletion", value)

    @property
    @pulumi.getter(name="nonFastForward")
    def non_fast_forward(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Prevent users with push access from force pushing to branches.
        """
        return pulumi.get(self, "non_fast_forward")

    @non_fast_forward.setter
    def non_fast_forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "non_fast_forward", value)

    @property
    @pulumi.getter(name="pullRequest")
    def pull_request(self) -> Optional[pulumi.Input['OrganizationRulesetRulesPullRequestArgs']]:
        """
        (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
        """
        return pulumi.get(self, "pull_request")

    @pull_request.setter
    def pull_request(self, value: Optional[pulumi.Input['OrganizationRulesetRulesPullRequestArgs']]):
        pulumi.set(self, "pull_request", value)

    @property
    @pulumi.getter(name="requiredCodeScanning")
    def required_code_scanning(self) -> Optional[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningArgs']]:
        """
        (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
        """
        return pulumi.get(self, "required_code_scanning")

    @required_code_scanning.setter
    def required_code_scanning(self, value: Optional[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningArgs']]):
        pulumi.set(self, "required_code_scanning", value)

    @property
    @pulumi.getter(name="requiredLinearHistory")
    def required_linear_history(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Prevent merge commits from being pushed to matching branches.
        """
        return pulumi.get(self, "required_linear_history")

    @required_linear_history.setter
    def required_linear_history(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_linear_history", value)

    @property
    @pulumi.getter(name="requiredSignatures")
    def required_signatures(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Commits pushed to matching branches must have verified signatures.
        """
        return pulumi.get(self, "required_signatures")

    @required_signatures.setter
    def required_signatures(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_signatures", value)

    @property
    @pulumi.getter(name="requiredStatusChecks")
    def required_status_checks(self) -> Optional[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksArgs']]:
        """
        (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
        """
        return pulumi.get(self, "required_status_checks")

    @required_status_checks.setter
    def required_status_checks(self, value: Optional[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksArgs']]):
        pulumi.set(self, "required_status_checks", value)

    @property
    @pulumi.getter(name="requiredWorkflows")
    def required_workflows(self) -> Optional[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsArgs']]:
        """
        (Block List, Max: 1) Define which Actions workflows must pass before changes can be merged into a branch matching the rule. Multiple workflows can be specified. (see below for nested schema)
        """
        return pulumi.get(self, "required_workflows")

    @required_workflows.setter
    def required_workflows(self, value: Optional[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsArgs']]):
        pulumi.set(self, "required_workflows", value)

    @property
    @pulumi.getter(name="tagNamePattern")
    def tag_name_pattern(self) -> Optional[pulumi.Input['OrganizationRulesetRulesTagNamePatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`. (see below for nested schema)
        """
        return pulumi.get(self, "tag_name_pattern")

    @tag_name_pattern.setter
    def tag_name_pattern(self, value: Optional[pulumi.Input['OrganizationRulesetRulesTagNamePatternArgs']]):
        pulumi.set(self, "tag_name_pattern", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Only allow users with bypass permission to update matching refs.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class OrganizationRulesetRulesBranchNamePatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    OrganizationRulesetRulesBranchNamePatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesBranchNamePatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class OrganizationRulesetRulesCommitAuthorEmailPatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    OrganizationRulesetRulesCommitAuthorEmailPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesCommitAuthorEmailPatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class OrganizationRulesetRulesCommitMessagePatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    OrganizationRulesetRulesCommitMessagePatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesCommitMessagePatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class OrganizationRulesetRulesCommitterEmailPatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    OrganizationRulesetRulesCommitterEmailPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesCommitterEmailPatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class OrganizationRulesetRulesPullRequestArgsDict(TypedDict):
        dismiss_stale_reviews_on_push: NotRequired[pulumi.Input[bool]]
        """
        New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
        """
        require_code_owner_review: NotRequired[pulumi.Input[bool]]
        """
        Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
        """
        require_last_push_approval: NotRequired[pulumi.Input[bool]]
        """
        Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
        """
        required_approving_review_count: NotRequired[pulumi.Input[int]]
        """
        The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
        """
        required_review_thread_resolution: NotRequired[pulumi.Input[bool]]
        """
        All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
        """
elif False:
    OrganizationRulesetRulesPullRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesPullRequestArgs:
    def __init__(__self__, *,
                 dismiss_stale_reviews_on_push: Optional[pulumi.Input[bool]] = None,
                 require_code_owner_review: Optional[pulumi.Input[bool]] = None,
                 require_last_push_approval: Optional[pulumi.Input[bool]] = None,
                 required_approving_review_count: Optional[pulumi.Input[int]] = None,
                 required_review_thread_resolution: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] dismiss_stale_reviews_on_push: New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
        :param pulumi.Input[bool] require_code_owner_review: Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
        :param pulumi.Input[bool] require_last_push_approval: Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
        :param pulumi.Input[int] required_approving_review_count: The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
        :param pulumi.Input[bool] required_review_thread_resolution: All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
        """
        if dismiss_stale_reviews_on_push is not None:
            pulumi.set(__self__, "dismiss_stale_reviews_on_push", dismiss_stale_reviews_on_push)
        if require_code_owner_review is not None:
            pulumi.set(__self__, "require_code_owner_review", require_code_owner_review)
        if require_last_push_approval is not None:
            pulumi.set(__self__, "require_last_push_approval", require_last_push_approval)
        if required_approving_review_count is not None:
            pulumi.set(__self__, "required_approving_review_count", required_approving_review_count)
        if required_review_thread_resolution is not None:
            pulumi.set(__self__, "required_review_thread_resolution", required_review_thread_resolution)

    @property
    @pulumi.getter(name="dismissStaleReviewsOnPush")
    def dismiss_stale_reviews_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
        """
        return pulumi.get(self, "dismiss_stale_reviews_on_push")

    @dismiss_stale_reviews_on_push.setter
    def dismiss_stale_reviews_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dismiss_stale_reviews_on_push", value)

    @property
    @pulumi.getter(name="requireCodeOwnerReview")
    def require_code_owner_review(self) -> Optional[pulumi.Input[bool]]:
        """
        Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
        """
        return pulumi.get(self, "require_code_owner_review")

    @require_code_owner_review.setter
    def require_code_owner_review(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_code_owner_review", value)

    @property
    @pulumi.getter(name="requireLastPushApproval")
    def require_last_push_approval(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
        """
        return pulumi.get(self, "require_last_push_approval")

    @require_last_push_approval.setter
    def require_last_push_approval(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_last_push_approval", value)

    @property
    @pulumi.getter(name="requiredApprovingReviewCount")
    def required_approving_review_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
        """
        return pulumi.get(self, "required_approving_review_count")

    @required_approving_review_count.setter
    def required_approving_review_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_approving_review_count", value)

    @property
    @pulumi.getter(name="requiredReviewThreadResolution")
    def required_review_thread_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
        """
        return pulumi.get(self, "required_review_thread_resolution")

    @required_review_thread_resolution.setter
    def required_review_thread_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_review_thread_resolution", value)


if not MYPY:
    class OrganizationRulesetRulesRequiredCodeScanningArgsDict(TypedDict):
        required_code_scanning_tools: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgsDict']]]
        """
        Tools that must provide code scanning results for this rule to pass.
        """
elif False:
    OrganizationRulesetRulesRequiredCodeScanningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesRequiredCodeScanningArgs:
    def __init__(__self__, *,
                 required_code_scanning_tools: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs']]] required_code_scanning_tools: Tools that must provide code scanning results for this rule to pass.
        """
        pulumi.set(__self__, "required_code_scanning_tools", required_code_scanning_tools)

    @property
    @pulumi.getter(name="requiredCodeScanningTools")
    def required_code_scanning_tools(self) -> pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs']]]:
        """
        Tools that must provide code scanning results for this rule to pass.
        """
        return pulumi.get(self, "required_code_scanning_tools")

    @required_code_scanning_tools.setter
    def required_code_scanning_tools(self, value: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs']]]):
        pulumi.set(self, "required_code_scanning_tools", value)


if not MYPY:
    class OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgsDict(TypedDict):
        alerts_threshold: pulumi.Input[str]
        """
        The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
        """
        security_alerts_threshold: pulumi.Input[str]
        """
        The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
        """
        tool: pulumi.Input[str]
        """
        The name of a code scanning tool.
        """
elif False:
    OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs:
    def __init__(__self__, *,
                 alerts_threshold: pulumi.Input[str],
                 security_alerts_threshold: pulumi.Input[str],
                 tool: pulumi.Input[str]):
        """
        :param pulumi.Input[str] alerts_threshold: The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
        :param pulumi.Input[str] security_alerts_threshold: The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
        :param pulumi.Input[str] tool: The name of a code scanning tool.
        """
        pulumi.set(__self__, "alerts_threshold", alerts_threshold)
        pulumi.set(__self__, "security_alerts_threshold", security_alerts_threshold)
        pulumi.set(__self__, "tool", tool)

    @property
    @pulumi.getter(name="alertsThreshold")
    def alerts_threshold(self) -> pulumi.Input[str]:
        """
        The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
        """
        return pulumi.get(self, "alerts_threshold")

    @alerts_threshold.setter
    def alerts_threshold(self, value: pulumi.Input[str]):
        pulumi.set(self, "alerts_threshold", value)

    @property
    @pulumi.getter(name="securityAlertsThreshold")
    def security_alerts_threshold(self) -> pulumi.Input[str]:
        """
        The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
        """
        return pulumi.get(self, "security_alerts_threshold")

    @security_alerts_threshold.setter
    def security_alerts_threshold(self, value: pulumi.Input[str]):
        pulumi.set(self, "security_alerts_threshold", value)

    @property
    @pulumi.getter
    def tool(self) -> pulumi.Input[str]:
        """
        The name of a code scanning tool.
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: pulumi.Input[str]):
        pulumi.set(self, "tool", value)


if not MYPY:
    class OrganizationRulesetRulesRequiredStatusChecksArgsDict(TypedDict):
        required_checks: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgsDict']]]
        """
        Status checks that are required. Several can be defined.
        """
        strict_required_status_checks_policy: NotRequired[pulumi.Input[bool]]
        """
        Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
        """
elif False:
    OrganizationRulesetRulesRequiredStatusChecksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesRequiredStatusChecksArgs:
    def __init__(__self__, *,
                 required_checks: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgs']]],
                 strict_required_status_checks_policy: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgs']]] required_checks: Status checks that are required. Several can be defined.
        :param pulumi.Input[bool] strict_required_status_checks_policy: Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
        """
        pulumi.set(__self__, "required_checks", required_checks)
        if strict_required_status_checks_policy is not None:
            pulumi.set(__self__, "strict_required_status_checks_policy", strict_required_status_checks_policy)

    @property
    @pulumi.getter(name="requiredChecks")
    def required_checks(self) -> pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgs']]]:
        """
        Status checks that are required. Several can be defined.
        """
        return pulumi.get(self, "required_checks")

    @required_checks.setter
    def required_checks(self, value: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgs']]]):
        pulumi.set(self, "required_checks", value)

    @property
    @pulumi.getter(name="strictRequiredStatusChecksPolicy")
    def strict_required_status_checks_policy(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
        """
        return pulumi.get(self, "strict_required_status_checks_policy")

    @strict_required_status_checks_policy.setter
    def strict_required_status_checks_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_required_status_checks_policy", value)


if not MYPY:
    class OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgsDict(TypedDict):
        context: pulumi.Input[str]
        """
        The status check context name that must be present on the commit.
        """
        integration_id: NotRequired[pulumi.Input[int]]
        """
        The optional integration ID that this status check must originate from.
        """
elif False:
    OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesRequiredStatusChecksRequiredCheckArgs:
    def __init__(__self__, *,
                 context: pulumi.Input[str],
                 integration_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] context: The status check context name that must be present on the commit.
        :param pulumi.Input[int] integration_id: The optional integration ID that this status check must originate from.
        """
        pulumi.set(__self__, "context", context)
        if integration_id is not None:
            pulumi.set(__self__, "integration_id", integration_id)

    @property
    @pulumi.getter
    def context(self) -> pulumi.Input[str]:
        """
        The status check context name that must be present on the commit.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: pulumi.Input[str]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> Optional[pulumi.Input[int]]:
        """
        The optional integration ID that this status check must originate from.
        """
        return pulumi.get(self, "integration_id")

    @integration_id.setter
    def integration_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integration_id", value)


if not MYPY:
    class OrganizationRulesetRulesRequiredWorkflowsArgsDict(TypedDict):
        required_workflows: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgsDict']]]
        """
        Actions workflows that are required. Several can be defined.
        """
elif False:
    OrganizationRulesetRulesRequiredWorkflowsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesRequiredWorkflowsArgs:
    def __init__(__self__, *,
                 required_workflows: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgs']]] required_workflows: Actions workflows that are required. Several can be defined.
        """
        pulumi.set(__self__, "required_workflows", required_workflows)

    @property
    @pulumi.getter(name="requiredWorkflows")
    def required_workflows(self) -> pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgs']]]:
        """
        Actions workflows that are required. Several can be defined.
        """
        return pulumi.get(self, "required_workflows")

    @required_workflows.setter
    def required_workflows(self, value: pulumi.Input[Sequence[pulumi.Input['OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgs']]]):
        pulumi.set(self, "required_workflows", value)


if not MYPY:
    class OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        The path to the workflow YAML definition file.
        """
        repository_id: pulumi.Input[int]
        """
        The repository in which the workflow is defined.
        """
        ref: NotRequired[pulumi.Input[str]]
        """
        The ref (branch or tag) of the workflow file to use.
        """
elif False:
    OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesRequiredWorkflowsRequiredWorkflowArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 repository_id: pulumi.Input[int],
                 ref: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: The path to the workflow YAML definition file.
        :param pulumi.Input[int] repository_id: The repository in which the workflow is defined.
        :param pulumi.Input[str] ref: The ref (branch or tag) of the workflow file to use.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "repository_id", repository_id)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to the workflow YAML definition file.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> pulumi.Input[int]:
        """
        The repository in which the workflow is defined.
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "repository_id", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[str]]:
        """
        The ref (branch or tag) of the workflow file to use.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class OrganizationRulesetRulesTagNamePatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    OrganizationRulesetRulesTagNamePatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationRulesetRulesTagNamePatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class OrganizationWebhookConfigurationArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        URL of the webhook
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        The content type for the payload. Valid values are either 'form' or 'json'.
        """
        insecure_ssl: NotRequired[pulumi.Input[bool]]
        """
        Insecure SSL boolean toggle. Defaults to 'false'.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        The shared secret for the webhook
        """
elif False:
    OrganizationWebhookConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationWebhookConfigurationArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 content_type: Optional[pulumi.Input[str]] = None,
                 insecure_ssl: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: URL of the webhook
        :param pulumi.Input[str] content_type: The content type for the payload. Valid values are either 'form' or 'json'.
        :param pulumi.Input[bool] insecure_ssl: Insecure SSL boolean toggle. Defaults to 'false'.
        :param pulumi.Input[str] secret: The shared secret for the webhook
        """
        pulumi.set(__self__, "url", url)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if insecure_ssl is not None:
            pulumi.set(__self__, "insecure_ssl", insecure_ssl)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL of the webhook
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The content type for the payload. Valid values are either 'form' or 'json'.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="insecureSsl")
    def insecure_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Insecure SSL boolean toggle. Defaults to 'false'.
        """
        return pulumi.get(self, "insecure_ssl")

    @insecure_ssl.setter
    def insecure_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_ssl", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        The shared secret for the webhook
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ProviderAppAuthArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The GitHub App ID.
        """
        installation_id: pulumi.Input[str]
        """
        The GitHub App installation instance ID.
        """
        pem_file: pulumi.Input[str]
        """
        The GitHub App PEM file contents.
        """
elif False:
    ProviderAppAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderAppAuthArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 installation_id: pulumi.Input[str],
                 pem_file: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The GitHub App ID.
        :param pulumi.Input[str] installation_id: The GitHub App installation instance ID.
        :param pulumi.Input[str] pem_file: The GitHub App PEM file contents.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "installation_id", installation_id)
        pulumi.set(__self__, "pem_file", pem_file)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The GitHub App ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> pulumi.Input[str]:
        """
        The GitHub App installation instance ID.
        """
        return pulumi.get(self, "installation_id")

    @installation_id.setter
    def installation_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "installation_id", value)

    @property
    @pulumi.getter(name="pemFile")
    def pem_file(self) -> pulumi.Input[str]:
        """
        The GitHub App PEM file contents.
        """
        return pulumi.get(self, "pem_file")

    @pem_file.setter
    def pem_file(self, value: pulumi.Input[str]):
        pulumi.set(self, "pem_file", value)


if not MYPY:
    class RepositoryCollaboratorsTeamArgsDict(TypedDict):
        team_id: pulumi.Input[str]
        """
        The GitHub team id or the GitHub team slug
        """
        permission: NotRequired[pulumi.Input[str]]
        """
        The permission of the outside collaborators for the repository.
        Must be one of `pull`, `triage`, `push`, `maintain`, `admin` or the name of an existing [custom repository role](https://docs.github.com/en/enterprise-cloud@latest/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization) within the organisation. Defaults to `pull`.
        Must be `push` for personal repositories. Defaults to `push`.
        """
elif False:
    RepositoryCollaboratorsTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryCollaboratorsTeamArgs:
    def __init__(__self__, *,
                 team_id: pulumi.Input[str],
                 permission: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] team_id: The GitHub team id or the GitHub team slug
        :param pulumi.Input[str] permission: The permission of the outside collaborators for the repository.
               Must be one of `pull`, `triage`, `push`, `maintain`, `admin` or the name of an existing [custom repository role](https://docs.github.com/en/enterprise-cloud@latest/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization) within the organisation. Defaults to `pull`.
               Must be `push` for personal repositories. Defaults to `push`.
        """
        pulumi.set(__self__, "team_id", team_id)
        if permission is not None:
            pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[str]:
        """
        The GitHub team id or the GitHub team slug
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter
    def permission(self) -> Optional[pulumi.Input[str]]:
        """
        The permission of the outside collaborators for the repository.
        Must be one of `pull`, `triage`, `push`, `maintain`, `admin` or the name of an existing [custom repository role](https://docs.github.com/en/enterprise-cloud@latest/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization) within the organisation. Defaults to `pull`.
        Must be `push` for personal repositories. Defaults to `push`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class RepositoryCollaboratorsUserArgsDict(TypedDict):
        username: pulumi.Input[str]
        """
        The user to add to the repository as a collaborator.
        """
        permission: NotRequired[pulumi.Input[str]]
        """
        The permission of the outside collaborators for the repository.
        Must be one of `pull`, `push`, `maintain`, `triage` or `admin` or the name of an existing [custom repository role](https://docs.github.com/en/enterprise-cloud@latest/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization) within the organization for organization-owned repositories.
        Must be `push` for personal repositories. Defaults to `push`.
        """
elif False:
    RepositoryCollaboratorsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryCollaboratorsUserArgs:
    def __init__(__self__, *,
                 username: pulumi.Input[str],
                 permission: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] username: The user to add to the repository as a collaborator.
        :param pulumi.Input[str] permission: The permission of the outside collaborators for the repository.
               Must be one of `pull`, `push`, `maintain`, `triage` or `admin` or the name of an existing [custom repository role](https://docs.github.com/en/enterprise-cloud@latest/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization) within the organization for organization-owned repositories.
               Must be `push` for personal repositories. Defaults to `push`.
        """
        pulumi.set(__self__, "username", username)
        if permission is not None:
            pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The user to add to the repository as a collaborator.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def permission(self) -> Optional[pulumi.Input[str]]:
        """
        The permission of the outside collaborators for the repository.
        Must be one of `pull`, `push`, `maintain`, `triage` or `admin` or the name of an existing [custom repository role](https://docs.github.com/en/enterprise-cloud@latest/organizations/managing-peoples-access-to-your-organization-with-roles/managing-custom-repository-roles-for-an-organization) within the organization for organization-owned repositories.
        Must be `push` for personal repositories. Defaults to `push`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class RepositoryEnvironmentDeploymentBranchPolicyArgsDict(TypedDict):
        custom_branch_policies: pulumi.Input[bool]
        """
        Whether only branches that match the specified name patterns can deploy to this environment.
        """
        protected_branches: pulumi.Input[bool]
        """
        Whether only branches with branch protection rules can deploy to this environment.
        """
elif False:
    RepositoryEnvironmentDeploymentBranchPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryEnvironmentDeploymentBranchPolicyArgs:
    def __init__(__self__, *,
                 custom_branch_policies: pulumi.Input[bool],
                 protected_branches: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] custom_branch_policies: Whether only branches that match the specified name patterns can deploy to this environment.
        :param pulumi.Input[bool] protected_branches: Whether only branches with branch protection rules can deploy to this environment.
        """
        pulumi.set(__self__, "custom_branch_policies", custom_branch_policies)
        pulumi.set(__self__, "protected_branches", protected_branches)

    @property
    @pulumi.getter(name="customBranchPolicies")
    def custom_branch_policies(self) -> pulumi.Input[bool]:
        """
        Whether only branches that match the specified name patterns can deploy to this environment.
        """
        return pulumi.get(self, "custom_branch_policies")

    @custom_branch_policies.setter
    def custom_branch_policies(self, value: pulumi.Input[bool]):
        pulumi.set(self, "custom_branch_policies", value)

    @property
    @pulumi.getter(name="protectedBranches")
    def protected_branches(self) -> pulumi.Input[bool]:
        """
        Whether only branches with branch protection rules can deploy to this environment.
        """
        return pulumi.get(self, "protected_branches")

    @protected_branches.setter
    def protected_branches(self, value: pulumi.Input[bool]):
        pulumi.set(self, "protected_branches", value)


if not MYPY:
    class RepositoryEnvironmentReviewerArgsDict(TypedDict):
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Up to 6 IDs for teams who may review jobs that reference the environment. Reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
        """
        users: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Up to 6 IDs for users who may review jobs that reference the environment. Reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
        """
elif False:
    RepositoryEnvironmentReviewerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryEnvironmentReviewerArgs:
    def __init__(__self__, *,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 users: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] teams: Up to 6 IDs for teams who may review jobs that reference the environment. Reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] users: Up to 6 IDs for users who may review jobs that reference the environment. Reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
        """
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if users is not None:
            pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Up to 6 IDs for teams who may review jobs that reference the environment. Reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "teams", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Up to 6 IDs for users who may review jobs that reference the environment. Reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class RepositoryPagesArgsDict(TypedDict):
        build_type: NotRequired[pulumi.Input[str]]
        """
        The type of GitHub Pages site to build. Can be `legacy` or `workflow`. If you use `legacy` as build type you need to set the option `source`.
        """
        cname: NotRequired[pulumi.Input[str]]
        """
        The custom domain for the repository. This can only be set after the repository has been created.
        """
        custom404: NotRequired[pulumi.Input[bool]]
        """
        Whether the rendered GitHub Pages site has a custom 404 page.
        """
        html_url: NotRequired[pulumi.Input[str]]
        """
        The absolute URL (including scheme) of the rendered GitHub Pages site e.g. `https://username.github.io`.
        """
        source: NotRequired[pulumi.Input['RepositoryPagesSourceArgsDict']]
        """
        The source branch and directory for the rendered Pages site. See GitHub Pages Source below for details.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        The GitHub Pages site's build status e.g. `building` or `built`.
        """
        url: NotRequired[pulumi.Input[str]]
elif False:
    RepositoryPagesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryPagesArgs:
    def __init__(__self__, *,
                 build_type: Optional[pulumi.Input[str]] = None,
                 cname: Optional[pulumi.Input[str]] = None,
                 custom404: Optional[pulumi.Input[bool]] = None,
                 html_url: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input['RepositoryPagesSourceArgs']] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] build_type: The type of GitHub Pages site to build. Can be `legacy` or `workflow`. If you use `legacy` as build type you need to set the option `source`.
        :param pulumi.Input[str] cname: The custom domain for the repository. This can only be set after the repository has been created.
        :param pulumi.Input[bool] custom404: Whether the rendered GitHub Pages site has a custom 404 page.
        :param pulumi.Input[str] html_url: The absolute URL (including scheme) of the rendered GitHub Pages site e.g. `https://username.github.io`.
        :param pulumi.Input['RepositoryPagesSourceArgs'] source: The source branch and directory for the rendered Pages site. See GitHub Pages Source below for details.
        :param pulumi.Input[str] status: The GitHub Pages site's build status e.g. `building` or `built`.
        """
        if build_type is not None:
            pulumi.set(__self__, "build_type", build_type)
        if cname is not None:
            pulumi.set(__self__, "cname", cname)
        if custom404 is not None:
            pulumi.set(__self__, "custom404", custom404)
        if html_url is not None:
            pulumi.set(__self__, "html_url", html_url)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="buildType")
    def build_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of GitHub Pages site to build. Can be `legacy` or `workflow`. If you use `legacy` as build type you need to set the option `source`.
        """
        return pulumi.get(self, "build_type")

    @build_type.setter
    def build_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_type", value)

    @property
    @pulumi.getter
    def cname(self) -> Optional[pulumi.Input[str]]:
        """
        The custom domain for the repository. This can only be set after the repository has been created.
        """
        return pulumi.get(self, "cname")

    @cname.setter
    def cname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cname", value)

    @property
    @pulumi.getter
    def custom404(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the rendered GitHub Pages site has a custom 404 page.
        """
        return pulumi.get(self, "custom404")

    @custom404.setter
    def custom404(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom404", value)

    @property
    @pulumi.getter(name="htmlUrl")
    def html_url(self) -> Optional[pulumi.Input[str]]:
        """
        The absolute URL (including scheme) of the rendered GitHub Pages site e.g. `https://username.github.io`.
        """
        return pulumi.get(self, "html_url")

    @html_url.setter
    def html_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "html_url", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['RepositoryPagesSourceArgs']]:
        """
        The source branch and directory for the rendered Pages site. See GitHub Pages Source below for details.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['RepositoryPagesSourceArgs']]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The GitHub Pages site's build status e.g. `building` or `built`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class RepositoryPagesSourceArgsDict(TypedDict):
        branch: pulumi.Input[str]
        """
        The repository branch used to publish the site's source files. (i.e. `main` or `gh-pages`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The repository directory from which the site publishes (Default: `/`).
        """
elif False:
    RepositoryPagesSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryPagesSourceArgs:
    def __init__(__self__, *,
                 branch: pulumi.Input[str],
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The repository branch used to publish the site's source files. (i.e. `main` or `gh-pages`.
        :param pulumi.Input[str] path: The repository directory from which the site publishes (Default: `/`).
        """
        pulumi.set(__self__, "branch", branch)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def branch(self) -> pulumi.Input[str]:
        """
        The repository branch used to publish the site's source files. (i.e. `main` or `gh-pages`.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: pulumi.Input[str]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The repository directory from which the site publishes (Default: `/`).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class RepositoryRulesetBypassActorArgsDict(TypedDict):
        actor_id: pulumi.Input[int]
        """
        (Number) The ID of the actor that can bypass a ruleset.
        """
        actor_type: pulumi.Input[str]
        """
        The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
        """
        bypass_mode: pulumi.Input[str]
        """
        (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.

        > Note: at the time of writing this, the following actor types correspond to the following actor IDs:
        * `OrganizationAdmin` > `1`
        * `RepositoryRole` (This is the actor type, the following are the base repository roles and their associated IDs.)
        """
elif False:
    RepositoryRulesetBypassActorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetBypassActorArgs:
    def __init__(__self__, *,
                 actor_id: pulumi.Input[int],
                 actor_type: pulumi.Input[str],
                 bypass_mode: pulumi.Input[str]):
        """
        :param pulumi.Input[int] actor_id: (Number) The ID of the actor that can bypass a ruleset.
        :param pulumi.Input[str] actor_type: The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
        :param pulumi.Input[str] bypass_mode: (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
               
               > Note: at the time of writing this, the following actor types correspond to the following actor IDs:
               * `OrganizationAdmin` > `1`
               * `RepositoryRole` (This is the actor type, the following are the base repository roles and their associated IDs.)
        """
        pulumi.set(__self__, "actor_id", actor_id)
        pulumi.set(__self__, "actor_type", actor_type)
        pulumi.set(__self__, "bypass_mode", bypass_mode)

    @property
    @pulumi.getter(name="actorId")
    def actor_id(self) -> pulumi.Input[int]:
        """
        (Number) The ID of the actor that can bypass a ruleset.
        """
        return pulumi.get(self, "actor_id")

    @actor_id.setter
    def actor_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "actor_id", value)

    @property
    @pulumi.getter(name="actorType")
    def actor_type(self) -> pulumi.Input[str]:
        """
        The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
        """
        return pulumi.get(self, "actor_type")

    @actor_type.setter
    def actor_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "actor_type", value)

    @property
    @pulumi.getter(name="bypassMode")
    def bypass_mode(self) -> pulumi.Input[str]:
        """
        (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.

        > Note: at the time of writing this, the following actor types correspond to the following actor IDs:
        * `OrganizationAdmin` > `1`
        * `RepositoryRole` (This is the actor type, the following are the base repository roles and their associated IDs.)
        """
        return pulumi.get(self, "bypass_mode")

    @bypass_mode.setter
    def bypass_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "bypass_mode", value)


if not MYPY:
    class RepositoryRulesetConditionsArgsDict(TypedDict):
        ref_name: pulumi.Input['RepositoryRulesetConditionsRefNameArgsDict']
        """
        (Block List, Min: 1, Max: 1) (see below for nested schema)
        """
elif False:
    RepositoryRulesetConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetConditionsArgs:
    def __init__(__self__, *,
                 ref_name: pulumi.Input['RepositoryRulesetConditionsRefNameArgs']):
        """
        :param pulumi.Input['RepositoryRulesetConditionsRefNameArgs'] ref_name: (Block List, Min: 1, Max: 1) (see below for nested schema)
        """
        pulumi.set(__self__, "ref_name", ref_name)

    @property
    @pulumi.getter(name="refName")
    def ref_name(self) -> pulumi.Input['RepositoryRulesetConditionsRefNameArgs']:
        """
        (Block List, Min: 1, Max: 1) (see below for nested schema)
        """
        return pulumi.get(self, "ref_name")

    @ref_name.setter
    def ref_name(self, value: pulumi.Input['RepositoryRulesetConditionsRefNameArgs']):
        pulumi.set(self, "ref_name", value)


if not MYPY:
    class RepositoryRulesetConditionsRefNameArgsDict(TypedDict):
        excludes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
        """
        includes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
        """
elif False:
    RepositoryRulesetConditionsRefNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetConditionsRefNameArgs:
    def __init__(__self__, *,
                 excludes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 includes: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excludes: Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] includes: Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
        """
        pulumi.set(__self__, "excludes", excludes)
        pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter
    def excludes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RepositoryRulesetRulesArgsDict(TypedDict):
        branch_name_pattern: NotRequired[pulumi.Input['RepositoryRulesetRulesBranchNamePatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
        """
        commit_author_email_pattern: NotRequired[pulumi.Input['RepositoryRulesetRulesCommitAuthorEmailPatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        commit_message_pattern: NotRequired[pulumi.Input['RepositoryRulesetRulesCommitMessagePatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        committer_email_pattern: NotRequired[pulumi.Input['RepositoryRulesetRulesCommitterEmailPatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        creation: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Only allow users with bypass permission to create matching refs.
        """
        deletion: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Only allow users with bypass permissions to delete matching refs.
        """
        non_fast_forward: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Prevent users with push access from force pushing to branches.
        """
        pull_request: NotRequired[pulumi.Input['RepositoryRulesetRulesPullRequestArgsDict']]
        """
        (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
        """
        required_code_scanning: NotRequired[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningArgsDict']]
        """
        (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
        """
        required_deployments: NotRequired[pulumi.Input['RepositoryRulesetRulesRequiredDeploymentsArgsDict']]
        """
        (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
        """
        required_linear_history: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Prevent merge commits from being pushed to matching branches.
        """
        required_signatures: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Commits pushed to matching branches must have verified signatures.
        """
        required_status_checks: NotRequired[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksArgsDict']]
        """
        (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
        """
        tag_name_pattern: NotRequired[pulumi.Input['RepositoryRulesetRulesTagNamePatternArgsDict']]
        """
        (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
        """
        update: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Only allow users with bypass permission to update matching refs.
        """
        update_allows_fetch_and_merge: NotRequired[pulumi.Input[bool]]
        """
        (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
        """
elif False:
    RepositoryRulesetRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesArgs:
    def __init__(__self__, *,
                 branch_name_pattern: Optional[pulumi.Input['RepositoryRulesetRulesBranchNamePatternArgs']] = None,
                 commit_author_email_pattern: Optional[pulumi.Input['RepositoryRulesetRulesCommitAuthorEmailPatternArgs']] = None,
                 commit_message_pattern: Optional[pulumi.Input['RepositoryRulesetRulesCommitMessagePatternArgs']] = None,
                 committer_email_pattern: Optional[pulumi.Input['RepositoryRulesetRulesCommitterEmailPatternArgs']] = None,
                 creation: Optional[pulumi.Input[bool]] = None,
                 deletion: Optional[pulumi.Input[bool]] = None,
                 non_fast_forward: Optional[pulumi.Input[bool]] = None,
                 pull_request: Optional[pulumi.Input['RepositoryRulesetRulesPullRequestArgs']] = None,
                 required_code_scanning: Optional[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningArgs']] = None,
                 required_deployments: Optional[pulumi.Input['RepositoryRulesetRulesRequiredDeploymentsArgs']] = None,
                 required_linear_history: Optional[pulumi.Input[bool]] = None,
                 required_signatures: Optional[pulumi.Input[bool]] = None,
                 required_status_checks: Optional[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksArgs']] = None,
                 tag_name_pattern: Optional[pulumi.Input['RepositoryRulesetRulesTagNamePatternArgs']] = None,
                 update: Optional[pulumi.Input[bool]] = None,
                 update_allows_fetch_and_merge: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['RepositoryRulesetRulesBranchNamePatternArgs'] branch_name_pattern: (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
        :param pulumi.Input['RepositoryRulesetRulesCommitAuthorEmailPatternArgs'] commit_author_email_pattern: (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        :param pulumi.Input['RepositoryRulesetRulesCommitMessagePatternArgs'] commit_message_pattern: (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        :param pulumi.Input['RepositoryRulesetRulesCommitterEmailPatternArgs'] committer_email_pattern: (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        :param pulumi.Input[bool] creation: (Boolean) Only allow users with bypass permission to create matching refs.
        :param pulumi.Input[bool] deletion: (Boolean) Only allow users with bypass permissions to delete matching refs.
        :param pulumi.Input[bool] non_fast_forward: (Boolean) Prevent users with push access from force pushing to branches.
        :param pulumi.Input['RepositoryRulesetRulesPullRequestArgs'] pull_request: (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
        :param pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningArgs'] required_code_scanning: (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
        :param pulumi.Input['RepositoryRulesetRulesRequiredDeploymentsArgs'] required_deployments: (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
        :param pulumi.Input[bool] required_linear_history: (Boolean) Prevent merge commits from being pushed to matching branches.
        :param pulumi.Input[bool] required_signatures: (Boolean) Commits pushed to matching branches must have verified signatures.
        :param pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksArgs'] required_status_checks: (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
        :param pulumi.Input['RepositoryRulesetRulesTagNamePatternArgs'] tag_name_pattern: (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
        :param pulumi.Input[bool] update: (Boolean) Only allow users with bypass permission to update matching refs.
        :param pulumi.Input[bool] update_allows_fetch_and_merge: (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
        """
        if branch_name_pattern is not None:
            pulumi.set(__self__, "branch_name_pattern", branch_name_pattern)
        if commit_author_email_pattern is not None:
            pulumi.set(__self__, "commit_author_email_pattern", commit_author_email_pattern)
        if commit_message_pattern is not None:
            pulumi.set(__self__, "commit_message_pattern", commit_message_pattern)
        if committer_email_pattern is not None:
            pulumi.set(__self__, "committer_email_pattern", committer_email_pattern)
        if creation is not None:
            pulumi.set(__self__, "creation", creation)
        if deletion is not None:
            pulumi.set(__self__, "deletion", deletion)
        if non_fast_forward is not None:
            pulumi.set(__self__, "non_fast_forward", non_fast_forward)
        if pull_request is not None:
            pulumi.set(__self__, "pull_request", pull_request)
        if required_code_scanning is not None:
            pulumi.set(__self__, "required_code_scanning", required_code_scanning)
        if required_deployments is not None:
            pulumi.set(__self__, "required_deployments", required_deployments)
        if required_linear_history is not None:
            pulumi.set(__self__, "required_linear_history", required_linear_history)
        if required_signatures is not None:
            pulumi.set(__self__, "required_signatures", required_signatures)
        if required_status_checks is not None:
            pulumi.set(__self__, "required_status_checks", required_status_checks)
        if tag_name_pattern is not None:
            pulumi.set(__self__, "tag_name_pattern", tag_name_pattern)
        if update is not None:
            pulumi.set(__self__, "update", update)
        if update_allows_fetch_and_merge is not None:
            pulumi.set(__self__, "update_allows_fetch_and_merge", update_allows_fetch_and_merge)

    @property
    @pulumi.getter(name="branchNamePattern")
    def branch_name_pattern(self) -> Optional[pulumi.Input['RepositoryRulesetRulesBranchNamePatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
        """
        return pulumi.get(self, "branch_name_pattern")

    @branch_name_pattern.setter
    def branch_name_pattern(self, value: Optional[pulumi.Input['RepositoryRulesetRulesBranchNamePatternArgs']]):
        pulumi.set(self, "branch_name_pattern", value)

    @property
    @pulumi.getter(name="commitAuthorEmailPattern")
    def commit_author_email_pattern(self) -> Optional[pulumi.Input['RepositoryRulesetRulesCommitAuthorEmailPatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        return pulumi.get(self, "commit_author_email_pattern")

    @commit_author_email_pattern.setter
    def commit_author_email_pattern(self, value: Optional[pulumi.Input['RepositoryRulesetRulesCommitAuthorEmailPatternArgs']]):
        pulumi.set(self, "commit_author_email_pattern", value)

    @property
    @pulumi.getter(name="commitMessagePattern")
    def commit_message_pattern(self) -> Optional[pulumi.Input['RepositoryRulesetRulesCommitMessagePatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        return pulumi.get(self, "commit_message_pattern")

    @commit_message_pattern.setter
    def commit_message_pattern(self, value: Optional[pulumi.Input['RepositoryRulesetRulesCommitMessagePatternArgs']]):
        pulumi.set(self, "commit_message_pattern", value)

    @property
    @pulumi.getter(name="committerEmailPattern")
    def committer_email_pattern(self) -> Optional[pulumi.Input['RepositoryRulesetRulesCommitterEmailPatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        """
        return pulumi.get(self, "committer_email_pattern")

    @committer_email_pattern.setter
    def committer_email_pattern(self, value: Optional[pulumi.Input['RepositoryRulesetRulesCommitterEmailPatternArgs']]):
        pulumi.set(self, "committer_email_pattern", value)

    @property
    @pulumi.getter
    def creation(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Only allow users with bypass permission to create matching refs.
        """
        return pulumi.get(self, "creation")

    @creation.setter
    def creation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "creation", value)

    @property
    @pulumi.getter
    def deletion(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Only allow users with bypass permissions to delete matching refs.
        """
        return pulumi.get(self, "deletion")

    @deletion.setter
    def deletion(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deletion", value)

    @property
    @pulumi.getter(name="nonFastForward")
    def non_fast_forward(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Prevent users with push access from force pushing to branches.
        """
        return pulumi.get(self, "non_fast_forward")

    @non_fast_forward.setter
    def non_fast_forward(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "non_fast_forward", value)

    @property
    @pulumi.getter(name="pullRequest")
    def pull_request(self) -> Optional[pulumi.Input['RepositoryRulesetRulesPullRequestArgs']]:
        """
        (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
        """
        return pulumi.get(self, "pull_request")

    @pull_request.setter
    def pull_request(self, value: Optional[pulumi.Input['RepositoryRulesetRulesPullRequestArgs']]):
        pulumi.set(self, "pull_request", value)

    @property
    @pulumi.getter(name="requiredCodeScanning")
    def required_code_scanning(self) -> Optional[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningArgs']]:
        """
        (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
        """
        return pulumi.get(self, "required_code_scanning")

    @required_code_scanning.setter
    def required_code_scanning(self, value: Optional[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningArgs']]):
        pulumi.set(self, "required_code_scanning", value)

    @property
    @pulumi.getter(name="requiredDeployments")
    def required_deployments(self) -> Optional[pulumi.Input['RepositoryRulesetRulesRequiredDeploymentsArgs']]:
        """
        (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
        """
        return pulumi.get(self, "required_deployments")

    @required_deployments.setter
    def required_deployments(self, value: Optional[pulumi.Input['RepositoryRulesetRulesRequiredDeploymentsArgs']]):
        pulumi.set(self, "required_deployments", value)

    @property
    @pulumi.getter(name="requiredLinearHistory")
    def required_linear_history(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Prevent merge commits from being pushed to matching branches.
        """
        return pulumi.get(self, "required_linear_history")

    @required_linear_history.setter
    def required_linear_history(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_linear_history", value)

    @property
    @pulumi.getter(name="requiredSignatures")
    def required_signatures(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Commits pushed to matching branches must have verified signatures.
        """
        return pulumi.get(self, "required_signatures")

    @required_signatures.setter
    def required_signatures(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_signatures", value)

    @property
    @pulumi.getter(name="requiredStatusChecks")
    def required_status_checks(self) -> Optional[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksArgs']]:
        """
        (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
        """
        return pulumi.get(self, "required_status_checks")

    @required_status_checks.setter
    def required_status_checks(self, value: Optional[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksArgs']]):
        pulumi.set(self, "required_status_checks", value)

    @property
    @pulumi.getter(name="tagNamePattern")
    def tag_name_pattern(self) -> Optional[pulumi.Input['RepositoryRulesetRulesTagNamePatternArgs']]:
        """
        (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
        """
        return pulumi.get(self, "tag_name_pattern")

    @tag_name_pattern.setter
    def tag_name_pattern(self, value: Optional[pulumi.Input['RepositoryRulesetRulesTagNamePatternArgs']]):
        pulumi.set(self, "tag_name_pattern", value)

    @property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Only allow users with bypass permission to update matching refs.
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update", value)

    @property
    @pulumi.getter(name="updateAllowsFetchAndMerge")
    def update_allows_fetch_and_merge(self) -> Optional[pulumi.Input[bool]]:
        """
        (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
        """
        return pulumi.get(self, "update_allows_fetch_and_merge")

    @update_allows_fetch_and_merge.setter
    def update_allows_fetch_and_merge(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update_allows_fetch_and_merge", value)


if not MYPY:
    class RepositoryRulesetRulesBranchNamePatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    RepositoryRulesetRulesBranchNamePatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesBranchNamePatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class RepositoryRulesetRulesCommitAuthorEmailPatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    RepositoryRulesetRulesCommitAuthorEmailPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesCommitAuthorEmailPatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class RepositoryRulesetRulesCommitMessagePatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    RepositoryRulesetRulesCommitMessagePatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesCommitMessagePatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class RepositoryRulesetRulesCommitterEmailPatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    RepositoryRulesetRulesCommitterEmailPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesCommitterEmailPatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class RepositoryRulesetRulesPullRequestArgsDict(TypedDict):
        dismiss_stale_reviews_on_push: NotRequired[pulumi.Input[bool]]
        """
        New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
        """
        require_code_owner_review: NotRequired[pulumi.Input[bool]]
        """
        Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
        """
        require_last_push_approval: NotRequired[pulumi.Input[bool]]
        """
        Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
        """
        required_approving_review_count: NotRequired[pulumi.Input[int]]
        """
        The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
        """
        required_review_thread_resolution: NotRequired[pulumi.Input[bool]]
        """
        All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
        """
elif False:
    RepositoryRulesetRulesPullRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesPullRequestArgs:
    def __init__(__self__, *,
                 dismiss_stale_reviews_on_push: Optional[pulumi.Input[bool]] = None,
                 require_code_owner_review: Optional[pulumi.Input[bool]] = None,
                 require_last_push_approval: Optional[pulumi.Input[bool]] = None,
                 required_approving_review_count: Optional[pulumi.Input[int]] = None,
                 required_review_thread_resolution: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] dismiss_stale_reviews_on_push: New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
        :param pulumi.Input[bool] require_code_owner_review: Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
        :param pulumi.Input[bool] require_last_push_approval: Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
        :param pulumi.Input[int] required_approving_review_count: The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
        :param pulumi.Input[bool] required_review_thread_resolution: All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
        """
        if dismiss_stale_reviews_on_push is not None:
            pulumi.set(__self__, "dismiss_stale_reviews_on_push", dismiss_stale_reviews_on_push)
        if require_code_owner_review is not None:
            pulumi.set(__self__, "require_code_owner_review", require_code_owner_review)
        if require_last_push_approval is not None:
            pulumi.set(__self__, "require_last_push_approval", require_last_push_approval)
        if required_approving_review_count is not None:
            pulumi.set(__self__, "required_approving_review_count", required_approving_review_count)
        if required_review_thread_resolution is not None:
            pulumi.set(__self__, "required_review_thread_resolution", required_review_thread_resolution)

    @property
    @pulumi.getter(name="dismissStaleReviewsOnPush")
    def dismiss_stale_reviews_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
        """
        return pulumi.get(self, "dismiss_stale_reviews_on_push")

    @dismiss_stale_reviews_on_push.setter
    def dismiss_stale_reviews_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dismiss_stale_reviews_on_push", value)

    @property
    @pulumi.getter(name="requireCodeOwnerReview")
    def require_code_owner_review(self) -> Optional[pulumi.Input[bool]]:
        """
        Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
        """
        return pulumi.get(self, "require_code_owner_review")

    @require_code_owner_review.setter
    def require_code_owner_review(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_code_owner_review", value)

    @property
    @pulumi.getter(name="requireLastPushApproval")
    def require_last_push_approval(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
        """
        return pulumi.get(self, "require_last_push_approval")

    @require_last_push_approval.setter
    def require_last_push_approval(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_last_push_approval", value)

    @property
    @pulumi.getter(name="requiredApprovingReviewCount")
    def required_approving_review_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
        """
        return pulumi.get(self, "required_approving_review_count")

    @required_approving_review_count.setter
    def required_approving_review_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "required_approving_review_count", value)

    @property
    @pulumi.getter(name="requiredReviewThreadResolution")
    def required_review_thread_resolution(self) -> Optional[pulumi.Input[bool]]:
        """
        All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
        """
        return pulumi.get(self, "required_review_thread_resolution")

    @required_review_thread_resolution.setter
    def required_review_thread_resolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required_review_thread_resolution", value)


if not MYPY:
    class RepositoryRulesetRulesRequiredCodeScanningArgsDict(TypedDict):
        required_code_scanning_tools: pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgsDict']]]
        """
        Tools that must provide code scanning results for this rule to pass.
        """
elif False:
    RepositoryRulesetRulesRequiredCodeScanningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesRequiredCodeScanningArgs:
    def __init__(__self__, *,
                 required_code_scanning_tools: pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs']]] required_code_scanning_tools: Tools that must provide code scanning results for this rule to pass.
        """
        pulumi.set(__self__, "required_code_scanning_tools", required_code_scanning_tools)

    @property
    @pulumi.getter(name="requiredCodeScanningTools")
    def required_code_scanning_tools(self) -> pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs']]]:
        """
        Tools that must provide code scanning results for this rule to pass.
        """
        return pulumi.get(self, "required_code_scanning_tools")

    @required_code_scanning_tools.setter
    def required_code_scanning_tools(self, value: pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs']]]):
        pulumi.set(self, "required_code_scanning_tools", value)


if not MYPY:
    class RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgsDict(TypedDict):
        alerts_threshold: pulumi.Input[str]
        """
        The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
        """
        security_alerts_threshold: pulumi.Input[str]
        """
        The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
        """
        tool: pulumi.Input[str]
        """
        The name of a code scanning tool
        """
elif False:
    RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesRequiredCodeScanningRequiredCodeScanningToolArgs:
    def __init__(__self__, *,
                 alerts_threshold: pulumi.Input[str],
                 security_alerts_threshold: pulumi.Input[str],
                 tool: pulumi.Input[str]):
        """
        :param pulumi.Input[str] alerts_threshold: The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
        :param pulumi.Input[str] security_alerts_threshold: The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
        :param pulumi.Input[str] tool: The name of a code scanning tool
        """
        pulumi.set(__self__, "alerts_threshold", alerts_threshold)
        pulumi.set(__self__, "security_alerts_threshold", security_alerts_threshold)
        pulumi.set(__self__, "tool", tool)

    @property
    @pulumi.getter(name="alertsThreshold")
    def alerts_threshold(self) -> pulumi.Input[str]:
        """
        The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
        """
        return pulumi.get(self, "alerts_threshold")

    @alerts_threshold.setter
    def alerts_threshold(self, value: pulumi.Input[str]):
        pulumi.set(self, "alerts_threshold", value)

    @property
    @pulumi.getter(name="securityAlertsThreshold")
    def security_alerts_threshold(self) -> pulumi.Input[str]:
        """
        The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
        """
        return pulumi.get(self, "security_alerts_threshold")

    @security_alerts_threshold.setter
    def security_alerts_threshold(self, value: pulumi.Input[str]):
        pulumi.set(self, "security_alerts_threshold", value)

    @property
    @pulumi.getter
    def tool(self) -> pulumi.Input[str]:
        """
        The name of a code scanning tool
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: pulumi.Input[str]):
        pulumi.set(self, "tool", value)


if not MYPY:
    class RepositoryRulesetRulesRequiredDeploymentsArgsDict(TypedDict):
        required_deployment_environments: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The environments that must be successfully deployed to before branches can be merged.
        """
elif False:
    RepositoryRulesetRulesRequiredDeploymentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesRequiredDeploymentsArgs:
    def __init__(__self__, *,
                 required_deployment_environments: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] required_deployment_environments: The environments that must be successfully deployed to before branches can be merged.
        """
        pulumi.set(__self__, "required_deployment_environments", required_deployment_environments)

    @property
    @pulumi.getter(name="requiredDeploymentEnvironments")
    def required_deployment_environments(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The environments that must be successfully deployed to before branches can be merged.
        """
        return pulumi.get(self, "required_deployment_environments")

    @required_deployment_environments.setter
    def required_deployment_environments(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "required_deployment_environments", value)


if not MYPY:
    class RepositoryRulesetRulesRequiredStatusChecksArgsDict(TypedDict):
        required_checks: pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgsDict']]]
        """
        Status checks that are required. Several can be defined.
        """
        strict_required_status_checks_policy: NotRequired[pulumi.Input[bool]]
        """
        Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
        """
elif False:
    RepositoryRulesetRulesRequiredStatusChecksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesRequiredStatusChecksArgs:
    def __init__(__self__, *,
                 required_checks: pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgs']]],
                 strict_required_status_checks_policy: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgs']]] required_checks: Status checks that are required. Several can be defined.
        :param pulumi.Input[bool] strict_required_status_checks_policy: Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
        """
        pulumi.set(__self__, "required_checks", required_checks)
        if strict_required_status_checks_policy is not None:
            pulumi.set(__self__, "strict_required_status_checks_policy", strict_required_status_checks_policy)

    @property
    @pulumi.getter(name="requiredChecks")
    def required_checks(self) -> pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgs']]]:
        """
        Status checks that are required. Several can be defined.
        """
        return pulumi.get(self, "required_checks")

    @required_checks.setter
    def required_checks(self, value: pulumi.Input[Sequence[pulumi.Input['RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgs']]]):
        pulumi.set(self, "required_checks", value)

    @property
    @pulumi.getter(name="strictRequiredStatusChecksPolicy")
    def strict_required_status_checks_policy(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
        """
        return pulumi.get(self, "strict_required_status_checks_policy")

    @strict_required_status_checks_policy.setter
    def strict_required_status_checks_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strict_required_status_checks_policy", value)


if not MYPY:
    class RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgsDict(TypedDict):
        context: pulumi.Input[str]
        """
        The status check context name that must be present on the commit.
        """
        integration_id: NotRequired[pulumi.Input[int]]
        """
        The optional integration ID that this status check must originate from.
        """
elif False:
    RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesRequiredStatusChecksRequiredCheckArgs:
    def __init__(__self__, *,
                 context: pulumi.Input[str],
                 integration_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] context: The status check context name that must be present on the commit.
        :param pulumi.Input[int] integration_id: The optional integration ID that this status check must originate from.
        """
        pulumi.set(__self__, "context", context)
        if integration_id is not None:
            pulumi.set(__self__, "integration_id", integration_id)

    @property
    @pulumi.getter
    def context(self) -> pulumi.Input[str]:
        """
        The status check context name that must be present on the commit.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: pulumi.Input[str]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> Optional[pulumi.Input[int]]:
        """
        The optional integration ID that this status check must originate from.
        """
        return pulumi.get(self, "integration_id")

    @integration_id.setter
    def integration_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integration_id", value)


if not MYPY:
    class RepositoryRulesetRulesTagNamePatternArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        pattern: pulumi.Input[str]
        """
        The pattern to match with.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (String) The name of the ruleset.
        """
        negate: NotRequired[pulumi.Input[bool]]
        """
        If true, the rule will fail if the pattern matches.
        """
elif False:
    RepositoryRulesetRulesTagNamePatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryRulesetRulesTagNamePatternArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 negate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        :param pulumi.Input[str] pattern: The pattern to match with.
        :param pulumi.Input[str] name: (String) The name of the ruleset.
        :param pulumi.Input[bool] negate: If true, the rule will fail if the pattern matches.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "pattern", pattern)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The pattern to match with.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (String) The name of the ruleset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the rule will fail if the pattern matches.
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class RepositorySecurityAndAnalysisArgsDict(TypedDict):
        advanced_security: NotRequired[pulumi.Input['RepositorySecurityAndAnalysisAdvancedSecurityArgsDict']]
        """
        The advanced security configuration for the repository. See Advanced Security Configuration below for details. If a repository's visibility is `public`, advanced security is always enabled and cannot be changed, so this setting cannot be supplied.
        """
        secret_scanning: NotRequired[pulumi.Input['RepositorySecurityAndAnalysisSecretScanningArgsDict']]
        """
        The secret scanning configuration for the repository. See Secret Scanning Configuration below for details.
        """
        secret_scanning_push_protection: NotRequired[pulumi.Input['RepositorySecurityAndAnalysisSecretScanningPushProtectionArgsDict']]
        """
        The secret scanning push protection configuration for the repository. See Secret Scanning Push Protection Configuration below for details.
        """
elif False:
    RepositorySecurityAndAnalysisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySecurityAndAnalysisArgs:
    def __init__(__self__, *,
                 advanced_security: Optional[pulumi.Input['RepositorySecurityAndAnalysisAdvancedSecurityArgs']] = None,
                 secret_scanning: Optional[pulumi.Input['RepositorySecurityAndAnalysisSecretScanningArgs']] = None,
                 secret_scanning_push_protection: Optional[pulumi.Input['RepositorySecurityAndAnalysisSecretScanningPushProtectionArgs']] = None):
        """
        :param pulumi.Input['RepositorySecurityAndAnalysisAdvancedSecurityArgs'] advanced_security: The advanced security configuration for the repository. See Advanced Security Configuration below for details. If a repository's visibility is `public`, advanced security is always enabled and cannot be changed, so this setting cannot be supplied.
        :param pulumi.Input['RepositorySecurityAndAnalysisSecretScanningArgs'] secret_scanning: The secret scanning configuration for the repository. See Secret Scanning Configuration below for details.
        :param pulumi.Input['RepositorySecurityAndAnalysisSecretScanningPushProtectionArgs'] secret_scanning_push_protection: The secret scanning push protection configuration for the repository. See Secret Scanning Push Protection Configuration below for details.
        """
        if advanced_security is not None:
            pulumi.set(__self__, "advanced_security", advanced_security)
        if secret_scanning is not None:
            pulumi.set(__self__, "secret_scanning", secret_scanning)
        if secret_scanning_push_protection is not None:
            pulumi.set(__self__, "secret_scanning_push_protection", secret_scanning_push_protection)

    @property
    @pulumi.getter(name="advancedSecurity")
    def advanced_security(self) -> Optional[pulumi.Input['RepositorySecurityAndAnalysisAdvancedSecurityArgs']]:
        """
        The advanced security configuration for the repository. See Advanced Security Configuration below for details. If a repository's visibility is `public`, advanced security is always enabled and cannot be changed, so this setting cannot be supplied.
        """
        return pulumi.get(self, "advanced_security")

    @advanced_security.setter
    def advanced_security(self, value: Optional[pulumi.Input['RepositorySecurityAndAnalysisAdvancedSecurityArgs']]):
        pulumi.set(self, "advanced_security", value)

    @property
    @pulumi.getter(name="secretScanning")
    def secret_scanning(self) -> Optional[pulumi.Input['RepositorySecurityAndAnalysisSecretScanningArgs']]:
        """
        The secret scanning configuration for the repository. See Secret Scanning Configuration below for details.
        """
        return pulumi.get(self, "secret_scanning")

    @secret_scanning.setter
    def secret_scanning(self, value: Optional[pulumi.Input['RepositorySecurityAndAnalysisSecretScanningArgs']]):
        pulumi.set(self, "secret_scanning", value)

    @property
    @pulumi.getter(name="secretScanningPushProtection")
    def secret_scanning_push_protection(self) -> Optional[pulumi.Input['RepositorySecurityAndAnalysisSecretScanningPushProtectionArgs']]:
        """
        The secret scanning push protection configuration for the repository. See Secret Scanning Push Protection Configuration below for details.
        """
        return pulumi.get(self, "secret_scanning_push_protection")

    @secret_scanning_push_protection.setter
    def secret_scanning_push_protection(self, value: Optional[pulumi.Input['RepositorySecurityAndAnalysisSecretScanningPushProtectionArgs']]):
        pulumi.set(self, "secret_scanning_push_protection", value)


if not MYPY:
    class RepositorySecurityAndAnalysisAdvancedSecurityArgsDict(TypedDict):
        status: pulumi.Input[str]
        """
        Set to `enabled` to enable advanced security features on the repository. Can be `enabled` or `disabled`.
        """
elif False:
    RepositorySecurityAndAnalysisAdvancedSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySecurityAndAnalysisAdvancedSecurityArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str]):
        """
        :param pulumi.Input[str] status: Set to `enabled` to enable advanced security features on the repository. Can be `enabled` or `disabled`.
        """
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        Set to `enabled` to enable advanced security features on the repository. Can be `enabled` or `disabled`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class RepositorySecurityAndAnalysisSecretScanningArgsDict(TypedDict):
        status: pulumi.Input[str]
        """
        The GitHub Pages site's build status e.g. `building` or `built`.
        """
elif False:
    RepositorySecurityAndAnalysisSecretScanningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySecurityAndAnalysisSecretScanningArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str]):
        """
        :param pulumi.Input[str] status: The GitHub Pages site's build status e.g. `building` or `built`.
        """
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        The GitHub Pages site's build status e.g. `building` or `built`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class RepositorySecurityAndAnalysisSecretScanningPushProtectionArgsDict(TypedDict):
        status: pulumi.Input[str]
        """
        The GitHub Pages site's build status e.g. `building` or `built`.
        """
elif False:
    RepositorySecurityAndAnalysisSecretScanningPushProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositorySecurityAndAnalysisSecretScanningPushProtectionArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str]):
        """
        :param pulumi.Input[str] status: The GitHub Pages site's build status e.g. `building` or `built`.
        """
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        The GitHub Pages site's build status e.g. `building` or `built`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)


if not MYPY:
    class RepositoryTemplateArgsDict(TypedDict):
        owner: pulumi.Input[str]
        """
        The GitHub organization or user the template repository is owned by.
        """
        repository: pulumi.Input[str]
        """
        The name of the template repository.
        """
        include_all_branches: NotRequired[pulumi.Input[bool]]
        """
        Whether the new repository should include all the branches from the template repository (defaults to false, which includes only the default branch from the template).
        """
elif False:
    RepositoryTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryTemplateArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input[str],
                 repository: pulumi.Input[str],
                 include_all_branches: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] owner: The GitHub organization or user the template repository is owned by.
        :param pulumi.Input[str] repository: The name of the template repository.
        :param pulumi.Input[bool] include_all_branches: Whether the new repository should include all the branches from the template repository (defaults to false, which includes only the default branch from the template).
        """
        pulumi.set(__self__, "owner", owner)
        pulumi.set(__self__, "repository", repository)
        if include_all_branches is not None:
            pulumi.set(__self__, "include_all_branches", include_all_branches)

    @property
    @pulumi.getter
    def owner(self) -> pulumi.Input[str]:
        """
        The GitHub organization or user the template repository is owned by.
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[str]:
        """
        The name of the template repository.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="includeAllBranches")
    def include_all_branches(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the new repository should include all the branches from the template repository (defaults to false, which includes only the default branch from the template).
        """
        return pulumi.get(self, "include_all_branches")

    @include_all_branches.setter
    def include_all_branches(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_all_branches", value)


if not MYPY:
    class RepositoryWebhookConfigurationArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The URL of the webhook.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        The content type for the payload. Valid values are either `form` or `json`.
        """
        insecure_ssl: NotRequired[pulumi.Input[bool]]
        """
        Insecure SSL boolean toggle. Defaults to `false`.
        """
        secret: NotRequired[pulumi.Input[str]]
        """
        The shared secret for the webhook. [See API documentation](https://developer.github.com/v3/repos/hooks/#create-a-hook).
        """
elif False:
    RepositoryWebhookConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepositoryWebhookConfigurationArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 content_type: Optional[pulumi.Input[str]] = None,
                 insecure_ssl: Optional[pulumi.Input[bool]] = None,
                 secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: The URL of the webhook.
        :param pulumi.Input[str] content_type: The content type for the payload. Valid values are either `form` or `json`.
        :param pulumi.Input[bool] insecure_ssl: Insecure SSL boolean toggle. Defaults to `false`.
        :param pulumi.Input[str] secret: The shared secret for the webhook. [See API documentation](https://developer.github.com/v3/repos/hooks/#create-a-hook).
        """
        pulumi.set(__self__, "url", url)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if insecure_ssl is not None:
            pulumi.set(__self__, "insecure_ssl", insecure_ssl)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL of the webhook.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The content type for the payload. Valid values are either `form` or `json`.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="insecureSsl")
    def insecure_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Insecure SSL boolean toggle. Defaults to `false`.
        """
        return pulumi.get(self, "insecure_ssl")

    @insecure_ssl.setter
    def insecure_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_ssl", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        The shared secret for the webhook. [See API documentation](https://developer.github.com/v3/repos/hooks/#create-a-hook).
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class TeamMembersMemberArgsDict(TypedDict):
        username: pulumi.Input[str]
        """
        The user to add to the team.
        """
        role: NotRequired[pulumi.Input[str]]
        """
        The role of the user within the team.
        Must be one of `member` or `maintainer`. Defaults to `member`.
        """
elif False:
    TeamMembersMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamMembersMemberArgs:
    def __init__(__self__, *,
                 username: pulumi.Input[str],
                 role: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] username: The user to add to the team.
        :param pulumi.Input[str] role: The role of the user within the team.
               Must be one of `member` or `maintainer`. Defaults to `member`.
        """
        pulumi.set(__self__, "username", username)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The user to add to the team.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        The role of the user within the team.
        Must be one of `member` or `maintainer`. Defaults to `member`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class TeamSettingsReviewRequestDelegationArgsDict(TypedDict):
        algorithm: NotRequired[pulumi.Input[str]]
        """
        The algorithm to use when assigning pull requests to team members. Supported values are 'ROUND_ROBIN' and 'LOAD_BALANCE'.
        """
        member_count: NotRequired[pulumi.Input[int]]
        """
        The number of team members to assign to a pull request.
        """
        notify: NotRequired[pulumi.Input[bool]]
        """
        whether to notify the entire team when at least one member is also assigned to the pull request.
        """
elif False:
    TeamSettingsReviewRequestDelegationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamSettingsReviewRequestDelegationArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 member_count: Optional[pulumi.Input[int]] = None,
                 notify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] algorithm: The algorithm to use when assigning pull requests to team members. Supported values are 'ROUND_ROBIN' and 'LOAD_BALANCE'.
        :param pulumi.Input[int] member_count: The number of team members to assign to a pull request.
        :param pulumi.Input[bool] notify: whether to notify the entire team when at least one member is also assigned to the pull request.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if member_count is not None:
            pulumi.set(__self__, "member_count", member_count)
        if notify is not None:
            pulumi.set(__self__, "notify", notify)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        The algorithm to use when assigning pull requests to team members. Supported values are 'ROUND_ROBIN' and 'LOAD_BALANCE'.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="memberCount")
    def member_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of team members to assign to a pull request.
        """
        return pulumi.get(self, "member_count")

    @member_count.setter
    def member_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "member_count", value)

    @property
    @pulumi.getter
    def notify(self) -> Optional[pulumi.Input[bool]]:
        """
        whether to notify the entire team when at least one member is also assigned to the pull request.
        """
        return pulumi.get(self, "notify")

    @notify.setter
    def notify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "notify", value)


if not MYPY:
    class TeamSyncGroupMappingGroupArgsDict(TypedDict):
        group_description: pulumi.Input[str]
        """
        The description of the IdP group.
        """
        group_id: pulumi.Input[str]
        """
        The ID of the IdP group.
        """
        group_name: pulumi.Input[str]
        """
        The name of the IdP group.
        """
elif False:
    TeamSyncGroupMappingGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TeamSyncGroupMappingGroupArgs:
    def __init__(__self__, *,
                 group_description: pulumi.Input[str],
                 group_id: pulumi.Input[str],
                 group_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] group_description: The description of the IdP group.
        :param pulumi.Input[str] group_id: The ID of the IdP group.
        :param pulumi.Input[str] group_name: The name of the IdP group.
        """
        pulumi.set(__self__, "group_description", group_description)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "group_name", group_name)

    @property
    @pulumi.getter(name="groupDescription")
    def group_description(self) -> pulumi.Input[str]:
        """
        The description of the IdP group.
        """
        return pulumi.get(self, "group_description")

    @group_description.setter
    def group_description(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_description", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[str]:
        """
        The ID of the IdP group.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[str]:
        """
        The name of the IdP group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_name", value)


