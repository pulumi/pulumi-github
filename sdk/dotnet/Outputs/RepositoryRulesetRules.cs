// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Github.Outputs
{

    [OutputType]
    public sealed class RepositoryRulesetRules
    {
        /// <summary>
        /// (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesBranchNamePattern? BranchNamePattern;
        /// <summary>
        /// (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesCommitAuthorEmailPattern? CommitAuthorEmailPattern;
        /// <summary>
        /// (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesCommitMessagePattern? CommitMessagePattern;
        /// <summary>
        /// (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesCommitterEmailPattern? CommitterEmailPattern;
        /// <summary>
        /// (Boolean) Only allow users with bypass permission to create matching refs.
        /// </summary>
        public readonly bool? Creation;
        /// <summary>
        /// (Boolean) Only allow users with bypass permissions to delete matching refs.
        /// </summary>
        public readonly bool? Deletion;
        /// <summary>
        /// (Boolean) Prevent users with push access from force pushing to branches.
        /// </summary>
        public readonly bool? NonFastForward;
        /// <summary>
        /// (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesPullRequest? PullRequest;
        /// <summary>
        /// (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesRequiredCodeScanning? RequiredCodeScanning;
        /// <summary>
        /// (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesRequiredDeployments? RequiredDeployments;
        /// <summary>
        /// (Boolean) Prevent merge commits from being pushed to matching branches.
        /// </summary>
        public readonly bool? RequiredLinearHistory;
        /// <summary>
        /// (Boolean) Commits pushed to matching branches must have verified signatures.
        /// </summary>
        public readonly bool? RequiredSignatures;
        /// <summary>
        /// (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesRequiredStatusChecks? RequiredStatusChecks;
        /// <summary>
        /// (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
        /// </summary>
        public readonly Outputs.RepositoryRulesetRulesTagNamePattern? TagNamePattern;
        /// <summary>
        /// (Boolean) Only allow users with bypass permission to update matching refs.
        /// </summary>
        public readonly bool? Update;
        /// <summary>
        /// (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
        /// </summary>
        public readonly bool? UpdateAllowsFetchAndMerge;

        [OutputConstructor]
        private RepositoryRulesetRules(
            Outputs.RepositoryRulesetRulesBranchNamePattern? branchNamePattern,

            Outputs.RepositoryRulesetRulesCommitAuthorEmailPattern? commitAuthorEmailPattern,

            Outputs.RepositoryRulesetRulesCommitMessagePattern? commitMessagePattern,

            Outputs.RepositoryRulesetRulesCommitterEmailPattern? committerEmailPattern,

            bool? creation,

            bool? deletion,

            bool? nonFastForward,

            Outputs.RepositoryRulesetRulesPullRequest? pullRequest,

            Outputs.RepositoryRulesetRulesRequiredCodeScanning? requiredCodeScanning,

            Outputs.RepositoryRulesetRulesRequiredDeployments? requiredDeployments,

            bool? requiredLinearHistory,

            bool? requiredSignatures,

            Outputs.RepositoryRulesetRulesRequiredStatusChecks? requiredStatusChecks,

            Outputs.RepositoryRulesetRulesTagNamePattern? tagNamePattern,

            bool? update,

            bool? updateAllowsFetchAndMerge)
        {
            BranchNamePattern = branchNamePattern;
            CommitAuthorEmailPattern = commitAuthorEmailPattern;
            CommitMessagePattern = commitMessagePattern;
            CommitterEmailPattern = committerEmailPattern;
            Creation = creation;
            Deletion = deletion;
            NonFastForward = nonFastForward;
            PullRequest = pullRequest;
            RequiredCodeScanning = requiredCodeScanning;
            RequiredDeployments = requiredDeployments;
            RequiredLinearHistory = requiredLinearHistory;
            RequiredSignatures = requiredSignatures;
            RequiredStatusChecks = requiredStatusChecks;
            TagNamePattern = tagNamePattern;
            Update = update;
            UpdateAllowsFetchAndMerge = updateAllowsFetchAndMerge;
        }
    }
}
