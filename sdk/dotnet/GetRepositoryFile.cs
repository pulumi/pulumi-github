// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Github
{
    public static class GetRepositoryFile
    {
        /// <summary>
        /// This data source allows you to read files within a
        /// GitHub repository.
        /// 
        /// 
        /// {{% examples %}}
        /// ## Example Usage
        /// {{% example %}}
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using Pulumi;
        /// using Github = Pulumi.Github;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var foo = Github.GetRepositoryFile.Invoke(new()
        ///     {
        ///         Repository = github_repository.Foo.Name,
        ///         Branch = "main",
        ///         File = ".gitignore",
        ///     });
        /// 
        /// });
        /// ```
        /// {{% /example %}}
        /// {{% /examples %}}
        /// </summary>
        public static Task<GetRepositoryFileResult> InvokeAsync(GetRepositoryFileArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.InvokeAsync<GetRepositoryFileResult>("github:index/getRepositoryFile:getRepositoryFile", args ?? new GetRepositoryFileArgs(), options.WithDefaults());

        /// <summary>
        /// This data source allows you to read files within a
        /// GitHub repository.
        /// 
        /// 
        /// {{% examples %}}
        /// ## Example Usage
        /// {{% example %}}
        /// 
        /// ```csharp
        /// using System.Collections.Generic;
        /// using Pulumi;
        /// using Github = Pulumi.Github;
        /// 
        /// return await Deployment.RunAsync(() =&gt; 
        /// {
        ///     var foo = Github.GetRepositoryFile.Invoke(new()
        ///     {
        ///         Repository = github_repository.Foo.Name,
        ///         Branch = "main",
        ///         File = ".gitignore",
        ///     });
        /// 
        /// });
        /// ```
        /// {{% /example %}}
        /// {{% /examples %}}
        /// </summary>
        public static Output<GetRepositoryFileResult> Invoke(GetRepositoryFileInvokeArgs args, InvokeOptions? options = null)
            => global::Pulumi.Deployment.Instance.Invoke<GetRepositoryFileResult>("github:index/getRepositoryFile:getRepositoryFile", args ?? new GetRepositoryFileInvokeArgs(), options.WithDefaults());
    }


    public sealed class GetRepositoryFileArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// Git branch (if omitted, the default repository branch is used, which is usually `main`)
        /// The branch must already exist; it will not be created if it does not already exist.
        /// </summary>
        [Input("branch")]
        public string? Branch { get; set; }

        /// <summary>
        /// The path of the file to manage.
        /// </summary>
        [Input("file", required: true)]
        public string File { get; set; } = null!;

        /// <summary>
        /// The repository to read the file from. If an unqualified repo name (without an owner) is passed, the owner will be inferred from the owner of the token used to execute the plan. If a name of the type "owner/repo" (with a slash in the middle) is passed, the owner will be as specified and not the owner of the token.
        /// </summary>
        [Input("repository", required: true)]
        public string Repository { get; set; } = null!;

        public GetRepositoryFileArgs()
        {
        }
        public static new GetRepositoryFileArgs Empty => new GetRepositoryFileArgs();
    }

    public sealed class GetRepositoryFileInvokeArgs : global::Pulumi.InvokeArgs
    {
        /// <summary>
        /// Git branch (if omitted, the default repository branch is used, which is usually `main`)
        /// The branch must already exist; it will not be created if it does not already exist.
        /// </summary>
        [Input("branch")]
        public Input<string>? Branch { get; set; }

        /// <summary>
        /// The path of the file to manage.
        /// </summary>
        [Input("file", required: true)]
        public Input<string> File { get; set; } = null!;

        /// <summary>
        /// The repository to read the file from. If an unqualified repo name (without an owner) is passed, the owner will be inferred from the owner of the token used to execute the plan. If a name of the type "owner/repo" (with a slash in the middle) is passed, the owner will be as specified and not the owner of the token.
        /// </summary>
        [Input("repository", required: true)]
        public Input<string> Repository { get; set; } = null!;

        public GetRepositoryFileInvokeArgs()
        {
        }
        public static new GetRepositoryFileInvokeArgs Empty => new GetRepositoryFileInvokeArgs();
    }


    [OutputType]
    public sealed class GetRepositoryFileResult
    {
        public readonly string? Branch;
        /// <summary>
        /// Committer author name.
        /// </summary>
        public readonly string CommitAuthor;
        /// <summary>
        /// Committer email address.
        /// </summary>
        public readonly string CommitEmail;
        /// <summary>
        /// Commit message when file was last updated.
        /// </summary>
        public readonly string CommitMessage;
        /// <summary>
        /// The SHA of the commit that modified the file.
        /// </summary>
        public readonly string CommitSha;
        /// <summary>
        /// The file content.
        /// </summary>
        public readonly string Content;
        public readonly string File;
        /// <summary>
        /// The provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;
        public readonly string Repository;
        /// <summary>
        /// The SHA blob of the file.
        /// </summary>
        public readonly string Sha;

        [OutputConstructor]
        private GetRepositoryFileResult(
            string? branch,

            string commitAuthor,

            string commitEmail,

            string commitMessage,

            string commitSha,

            string content,

            string file,

            string id,

            string repository,

            string sha)
        {
            Branch = branch;
            CommitAuthor = commitAuthor;
            CommitEmail = commitEmail;
            CommitMessage = commitMessage;
            CommitSha = commitSha;
            Content = content;
            File = file;
            Id = id;
            Repository = repository;
            Sha = sha;
        }
    }
}
