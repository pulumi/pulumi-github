// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.github.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.github.outputs.GetRepositoryPage;
import com.pulumi.github.outputs.GetRepositoryRepositoryLicense;
import com.pulumi.github.outputs.GetRepositoryTemplate;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetRepositoryResult {
    /**
     * @return Whether the repository allows auto-merging pull requests.
     * 
     */
    private Boolean allowAutoMerge;
    /**
     * @return Whether the repository allows merge commits.
     * 
     */
    private Boolean allowMergeCommit;
    /**
     * @return Whether the repository allows rebase merges.
     * 
     */
    private Boolean allowRebaseMerge;
    /**
     * @return Whether the repository allows squash merges.
     * 
     */
    private Boolean allowSquashMerge;
    private Boolean allowUpdateBranch;
    /**
     * @return Whether the repository is archived.
     * 
     */
    private Boolean archived;
    /**
     * @return The name of the default branch of the repository.
     * 
     */
    private String defaultBranch;
    private Boolean deleteBranchOnMerge;
    /**
     * @return A description of the license.
     * 
     */
    private @Nullable String description;
    /**
     * @return Whether the repository is a fork.
     * 
     */
    private Boolean fork;
    private String fullName;
    /**
     * @return URL that can be provided to `git clone` to clone the repository anonymously via the git protocol.
     * 
     */
    private String gitCloneUrl;
    /**
     * @return Whether the repository has GitHub Discussions enabled.
     * 
     */
    private Boolean hasDiscussions;
    /**
     * @return Whether the repository has Downloads feature enabled.
     * 
     */
    private Boolean hasDownloads;
    /**
     * @return Whether the repository has GitHub Issues enabled.
     * 
     */
    private Boolean hasIssues;
    /**
     * @return Whether the repository has the GitHub Projects enabled.
     * 
     */
    private Boolean hasProjects;
    /**
     * @return Whether the repository has the GitHub Wiki enabled.
     * 
     */
    private Boolean hasWiki;
    /**
     * @return URL of a page describing the project.
     * 
     */
    private @Nullable String homepageUrl;
    /**
     * @return The URL to view the license details on GitHub.
     * 
     */
    private String htmlUrl;
    /**
     * @return URL that can be provided to `git clone` to clone the repository via HTTPS.
     * 
     */
    private String httpCloneUrl;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    /**
     * @return Whether the repository is a template repository.
     * 
     */
    private Boolean isTemplate;
    /**
     * @return The default value for a merge commit message.
     * 
     */
    private String mergeCommitMessage;
    /**
     * @return The default value for a merge commit title.
     * 
     */
    private String mergeCommitTitle;
    /**
     * @return The name of the license (e.g., &#34;Apache License 2.0&#34;).
     * 
     */
    private String name;
    /**
     * @return GraphQL global node id for use with v4 API
     * 
     */
    private String nodeId;
    /**
     * @return The repository&#39;s GitHub Pages configuration.
     * 
     */
    private List<GetRepositoryPage> pages;
    /**
     * @return The primary language used in the repository.
     * 
     */
    private String primaryLanguage;
    /**
     * @return Whether the repository is private.
     * 
     */
    private Boolean private_;
    /**
     * @return GitHub ID for the repository
     * 
     */
    private Integer repoId;
    /**
     * @return An Array of GitHub repository licenses. Each `repository_license` block consists of the fields documented below.
     * 
     */
    private List<GetRepositoryRepositoryLicense> repositoryLicenses;
    /**
     * @return The default value for a squash merge commit message.
     * 
     */
    private String squashMergeCommitMessage;
    /**
     * @return The default value for a squash merge commit title.
     * 
     */
    private String squashMergeCommitTitle;
    /**
     * @return URL that can be provided to `git clone` to clone the repository via SSH.
     * 
     */
    private String sshCloneUrl;
    /**
     * @return URL that can be provided to `svn checkout` to check out the repository via GitHub&#39;s Subversion protocol emulation.
     * 
     */
    private String svnUrl;
    /**
     * @return The repository source template configuration.
     * 
     */
    private List<GetRepositoryTemplate> templates;
    /**
     * @return The list of topics of the repository.
     * 
     */
    private List<String> topics;
    /**
     * @return Whether the repository is public, private or internal.
     * 
     */
    private String visibility;

    private GetRepositoryResult() {}
    /**
     * @return Whether the repository allows auto-merging pull requests.
     * 
     */
    public Boolean allowAutoMerge() {
        return this.allowAutoMerge;
    }
    /**
     * @return Whether the repository allows merge commits.
     * 
     */
    public Boolean allowMergeCommit() {
        return this.allowMergeCommit;
    }
    /**
     * @return Whether the repository allows rebase merges.
     * 
     */
    public Boolean allowRebaseMerge() {
        return this.allowRebaseMerge;
    }
    /**
     * @return Whether the repository allows squash merges.
     * 
     */
    public Boolean allowSquashMerge() {
        return this.allowSquashMerge;
    }
    public Boolean allowUpdateBranch() {
        return this.allowUpdateBranch;
    }
    /**
     * @return Whether the repository is archived.
     * 
     */
    public Boolean archived() {
        return this.archived;
    }
    /**
     * @return The name of the default branch of the repository.
     * 
     */
    public String defaultBranch() {
        return this.defaultBranch;
    }
    public Boolean deleteBranchOnMerge() {
        return this.deleteBranchOnMerge;
    }
    /**
     * @return A description of the license.
     * 
     */
    public Optional<String> description() {
        return Optional.ofNullable(this.description);
    }
    /**
     * @return Whether the repository is a fork.
     * 
     */
    public Boolean fork() {
        return this.fork;
    }
    public String fullName() {
        return this.fullName;
    }
    /**
     * @return URL that can be provided to `git clone` to clone the repository anonymously via the git protocol.
     * 
     */
    public String gitCloneUrl() {
        return this.gitCloneUrl;
    }
    /**
     * @return Whether the repository has GitHub Discussions enabled.
     * 
     */
    public Boolean hasDiscussions() {
        return this.hasDiscussions;
    }
    /**
     * @return Whether the repository has Downloads feature enabled.
     * 
     */
    public Boolean hasDownloads() {
        return this.hasDownloads;
    }
    /**
     * @return Whether the repository has GitHub Issues enabled.
     * 
     */
    public Boolean hasIssues() {
        return this.hasIssues;
    }
    /**
     * @return Whether the repository has the GitHub Projects enabled.
     * 
     */
    public Boolean hasProjects() {
        return this.hasProjects;
    }
    /**
     * @return Whether the repository has the GitHub Wiki enabled.
     * 
     */
    public Boolean hasWiki() {
        return this.hasWiki;
    }
    /**
     * @return URL of a page describing the project.
     * 
     */
    public Optional<String> homepageUrl() {
        return Optional.ofNullable(this.homepageUrl);
    }
    /**
     * @return The URL to view the license details on GitHub.
     * 
     */
    public String htmlUrl() {
        return this.htmlUrl;
    }
    /**
     * @return URL that can be provided to `git clone` to clone the repository via HTTPS.
     * 
     */
    public String httpCloneUrl() {
        return this.httpCloneUrl;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Whether the repository is a template repository.
     * 
     */
    public Boolean isTemplate() {
        return this.isTemplate;
    }
    /**
     * @return The default value for a merge commit message.
     * 
     */
    public String mergeCommitMessage() {
        return this.mergeCommitMessage;
    }
    /**
     * @return The default value for a merge commit title.
     * 
     */
    public String mergeCommitTitle() {
        return this.mergeCommitTitle;
    }
    /**
     * @return The name of the license (e.g., &#34;Apache License 2.0&#34;).
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return GraphQL global node id for use with v4 API
     * 
     */
    public String nodeId() {
        return this.nodeId;
    }
    /**
     * @return The repository&#39;s GitHub Pages configuration.
     * 
     */
    public List<GetRepositoryPage> pages() {
        return this.pages;
    }
    /**
     * @return The primary language used in the repository.
     * 
     */
    public String primaryLanguage() {
        return this.primaryLanguage;
    }
    /**
     * @return Whether the repository is private.
     * 
     */
    public Boolean private_() {
        return this.private_;
    }
    /**
     * @return GitHub ID for the repository
     * 
     */
    public Integer repoId() {
        return this.repoId;
    }
    /**
     * @return An Array of GitHub repository licenses. Each `repository_license` block consists of the fields documented below.
     * 
     */
    public List<GetRepositoryRepositoryLicense> repositoryLicenses() {
        return this.repositoryLicenses;
    }
    /**
     * @return The default value for a squash merge commit message.
     * 
     */
    public String squashMergeCommitMessage() {
        return this.squashMergeCommitMessage;
    }
    /**
     * @return The default value for a squash merge commit title.
     * 
     */
    public String squashMergeCommitTitle() {
        return this.squashMergeCommitTitle;
    }
    /**
     * @return URL that can be provided to `git clone` to clone the repository via SSH.
     * 
     */
    public String sshCloneUrl() {
        return this.sshCloneUrl;
    }
    /**
     * @return URL that can be provided to `svn checkout` to check out the repository via GitHub&#39;s Subversion protocol emulation.
     * 
     */
    public String svnUrl() {
        return this.svnUrl;
    }
    /**
     * @return The repository source template configuration.
     * 
     */
    public List<GetRepositoryTemplate> templates() {
        return this.templates;
    }
    /**
     * @return The list of topics of the repository.
     * 
     */
    public List<String> topics() {
        return this.topics;
    }
    /**
     * @return Whether the repository is public, private or internal.
     * 
     */
    public String visibility() {
        return this.visibility;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetRepositoryResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean allowAutoMerge;
        private Boolean allowMergeCommit;
        private Boolean allowRebaseMerge;
        private Boolean allowSquashMerge;
        private Boolean allowUpdateBranch;
        private Boolean archived;
        private String defaultBranch;
        private Boolean deleteBranchOnMerge;
        private @Nullable String description;
        private Boolean fork;
        private String fullName;
        private String gitCloneUrl;
        private Boolean hasDiscussions;
        private Boolean hasDownloads;
        private Boolean hasIssues;
        private Boolean hasProjects;
        private Boolean hasWiki;
        private @Nullable String homepageUrl;
        private String htmlUrl;
        private String httpCloneUrl;
        private String id;
        private Boolean isTemplate;
        private String mergeCommitMessage;
        private String mergeCommitTitle;
        private String name;
        private String nodeId;
        private List<GetRepositoryPage> pages;
        private String primaryLanguage;
        private Boolean private_;
        private Integer repoId;
        private List<GetRepositoryRepositoryLicense> repositoryLicenses;
        private String squashMergeCommitMessage;
        private String squashMergeCommitTitle;
        private String sshCloneUrl;
        private String svnUrl;
        private List<GetRepositoryTemplate> templates;
        private List<String> topics;
        private String visibility;
        public Builder() {}
        public Builder(GetRepositoryResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allowAutoMerge = defaults.allowAutoMerge;
    	      this.allowMergeCommit = defaults.allowMergeCommit;
    	      this.allowRebaseMerge = defaults.allowRebaseMerge;
    	      this.allowSquashMerge = defaults.allowSquashMerge;
    	      this.allowUpdateBranch = defaults.allowUpdateBranch;
    	      this.archived = defaults.archived;
    	      this.defaultBranch = defaults.defaultBranch;
    	      this.deleteBranchOnMerge = defaults.deleteBranchOnMerge;
    	      this.description = defaults.description;
    	      this.fork = defaults.fork;
    	      this.fullName = defaults.fullName;
    	      this.gitCloneUrl = defaults.gitCloneUrl;
    	      this.hasDiscussions = defaults.hasDiscussions;
    	      this.hasDownloads = defaults.hasDownloads;
    	      this.hasIssues = defaults.hasIssues;
    	      this.hasProjects = defaults.hasProjects;
    	      this.hasWiki = defaults.hasWiki;
    	      this.homepageUrl = defaults.homepageUrl;
    	      this.htmlUrl = defaults.htmlUrl;
    	      this.httpCloneUrl = defaults.httpCloneUrl;
    	      this.id = defaults.id;
    	      this.isTemplate = defaults.isTemplate;
    	      this.mergeCommitMessage = defaults.mergeCommitMessage;
    	      this.mergeCommitTitle = defaults.mergeCommitTitle;
    	      this.name = defaults.name;
    	      this.nodeId = defaults.nodeId;
    	      this.pages = defaults.pages;
    	      this.primaryLanguage = defaults.primaryLanguage;
    	      this.private_ = defaults.private_;
    	      this.repoId = defaults.repoId;
    	      this.repositoryLicenses = defaults.repositoryLicenses;
    	      this.squashMergeCommitMessage = defaults.squashMergeCommitMessage;
    	      this.squashMergeCommitTitle = defaults.squashMergeCommitTitle;
    	      this.sshCloneUrl = defaults.sshCloneUrl;
    	      this.svnUrl = defaults.svnUrl;
    	      this.templates = defaults.templates;
    	      this.topics = defaults.topics;
    	      this.visibility = defaults.visibility;
        }

        @CustomType.Setter
        public Builder allowAutoMerge(Boolean allowAutoMerge) {
            if (allowAutoMerge == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "allowAutoMerge");
            }
            this.allowAutoMerge = allowAutoMerge;
            return this;
        }
        @CustomType.Setter
        public Builder allowMergeCommit(Boolean allowMergeCommit) {
            if (allowMergeCommit == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "allowMergeCommit");
            }
            this.allowMergeCommit = allowMergeCommit;
            return this;
        }
        @CustomType.Setter
        public Builder allowRebaseMerge(Boolean allowRebaseMerge) {
            if (allowRebaseMerge == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "allowRebaseMerge");
            }
            this.allowRebaseMerge = allowRebaseMerge;
            return this;
        }
        @CustomType.Setter
        public Builder allowSquashMerge(Boolean allowSquashMerge) {
            if (allowSquashMerge == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "allowSquashMerge");
            }
            this.allowSquashMerge = allowSquashMerge;
            return this;
        }
        @CustomType.Setter
        public Builder allowUpdateBranch(Boolean allowUpdateBranch) {
            if (allowUpdateBranch == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "allowUpdateBranch");
            }
            this.allowUpdateBranch = allowUpdateBranch;
            return this;
        }
        @CustomType.Setter
        public Builder archived(Boolean archived) {
            if (archived == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "archived");
            }
            this.archived = archived;
            return this;
        }
        @CustomType.Setter
        public Builder defaultBranch(String defaultBranch) {
            if (defaultBranch == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "defaultBranch");
            }
            this.defaultBranch = defaultBranch;
            return this;
        }
        @CustomType.Setter
        public Builder deleteBranchOnMerge(Boolean deleteBranchOnMerge) {
            if (deleteBranchOnMerge == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "deleteBranchOnMerge");
            }
            this.deleteBranchOnMerge = deleteBranchOnMerge;
            return this;
        }
        @CustomType.Setter
        public Builder description(@Nullable String description) {

            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder fork(Boolean fork) {
            if (fork == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "fork");
            }
            this.fork = fork;
            return this;
        }
        @CustomType.Setter
        public Builder fullName(String fullName) {
            if (fullName == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "fullName");
            }
            this.fullName = fullName;
            return this;
        }
        @CustomType.Setter
        public Builder gitCloneUrl(String gitCloneUrl) {
            if (gitCloneUrl == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "gitCloneUrl");
            }
            this.gitCloneUrl = gitCloneUrl;
            return this;
        }
        @CustomType.Setter
        public Builder hasDiscussions(Boolean hasDiscussions) {
            if (hasDiscussions == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "hasDiscussions");
            }
            this.hasDiscussions = hasDiscussions;
            return this;
        }
        @CustomType.Setter
        public Builder hasDownloads(Boolean hasDownloads) {
            if (hasDownloads == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "hasDownloads");
            }
            this.hasDownloads = hasDownloads;
            return this;
        }
        @CustomType.Setter
        public Builder hasIssues(Boolean hasIssues) {
            if (hasIssues == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "hasIssues");
            }
            this.hasIssues = hasIssues;
            return this;
        }
        @CustomType.Setter
        public Builder hasProjects(Boolean hasProjects) {
            if (hasProjects == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "hasProjects");
            }
            this.hasProjects = hasProjects;
            return this;
        }
        @CustomType.Setter
        public Builder hasWiki(Boolean hasWiki) {
            if (hasWiki == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "hasWiki");
            }
            this.hasWiki = hasWiki;
            return this;
        }
        @CustomType.Setter
        public Builder homepageUrl(@Nullable String homepageUrl) {

            this.homepageUrl = homepageUrl;
            return this;
        }
        @CustomType.Setter
        public Builder htmlUrl(String htmlUrl) {
            if (htmlUrl == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "htmlUrl");
            }
            this.htmlUrl = htmlUrl;
            return this;
        }
        @CustomType.Setter
        public Builder httpCloneUrl(String httpCloneUrl) {
            if (httpCloneUrl == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "httpCloneUrl");
            }
            this.httpCloneUrl = httpCloneUrl;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder isTemplate(Boolean isTemplate) {
            if (isTemplate == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "isTemplate");
            }
            this.isTemplate = isTemplate;
            return this;
        }
        @CustomType.Setter
        public Builder mergeCommitMessage(String mergeCommitMessage) {
            if (mergeCommitMessage == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "mergeCommitMessage");
            }
            this.mergeCommitMessage = mergeCommitMessage;
            return this;
        }
        @CustomType.Setter
        public Builder mergeCommitTitle(String mergeCommitTitle) {
            if (mergeCommitTitle == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "mergeCommitTitle");
            }
            this.mergeCommitTitle = mergeCommitTitle;
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder nodeId(String nodeId) {
            if (nodeId == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "nodeId");
            }
            this.nodeId = nodeId;
            return this;
        }
        @CustomType.Setter
        public Builder pages(List<GetRepositoryPage> pages) {
            if (pages == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "pages");
            }
            this.pages = pages;
            return this;
        }
        public Builder pages(GetRepositoryPage... pages) {
            return pages(List.of(pages));
        }
        @CustomType.Setter
        public Builder primaryLanguage(String primaryLanguage) {
            if (primaryLanguage == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "primaryLanguage");
            }
            this.primaryLanguage = primaryLanguage;
            return this;
        }
        @CustomType.Setter("private")
        public Builder private_(Boolean private_) {
            if (private_ == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "private_");
            }
            this.private_ = private_;
            return this;
        }
        @CustomType.Setter
        public Builder repoId(Integer repoId) {
            if (repoId == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "repoId");
            }
            this.repoId = repoId;
            return this;
        }
        @CustomType.Setter
        public Builder repositoryLicenses(List<GetRepositoryRepositoryLicense> repositoryLicenses) {
            if (repositoryLicenses == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "repositoryLicenses");
            }
            this.repositoryLicenses = repositoryLicenses;
            return this;
        }
        public Builder repositoryLicenses(GetRepositoryRepositoryLicense... repositoryLicenses) {
            return repositoryLicenses(List.of(repositoryLicenses));
        }
        @CustomType.Setter
        public Builder squashMergeCommitMessage(String squashMergeCommitMessage) {
            if (squashMergeCommitMessage == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "squashMergeCommitMessage");
            }
            this.squashMergeCommitMessage = squashMergeCommitMessage;
            return this;
        }
        @CustomType.Setter
        public Builder squashMergeCommitTitle(String squashMergeCommitTitle) {
            if (squashMergeCommitTitle == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "squashMergeCommitTitle");
            }
            this.squashMergeCommitTitle = squashMergeCommitTitle;
            return this;
        }
        @CustomType.Setter
        public Builder sshCloneUrl(String sshCloneUrl) {
            if (sshCloneUrl == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "sshCloneUrl");
            }
            this.sshCloneUrl = sshCloneUrl;
            return this;
        }
        @CustomType.Setter
        public Builder svnUrl(String svnUrl) {
            if (svnUrl == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "svnUrl");
            }
            this.svnUrl = svnUrl;
            return this;
        }
        @CustomType.Setter
        public Builder templates(List<GetRepositoryTemplate> templates) {
            if (templates == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "templates");
            }
            this.templates = templates;
            return this;
        }
        public Builder templates(GetRepositoryTemplate... templates) {
            return templates(List.of(templates));
        }
        @CustomType.Setter
        public Builder topics(List<String> topics) {
            if (topics == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "topics");
            }
            this.topics = topics;
            return this;
        }
        public Builder topics(String... topics) {
            return topics(List.of(topics));
        }
        @CustomType.Setter
        public Builder visibility(String visibility) {
            if (visibility == null) {
              throw new MissingRequiredPropertyException("GetRepositoryResult", "visibility");
            }
            this.visibility = visibility;
            return this;
        }
        public GetRepositoryResult build() {
            final var _resultValue = new GetRepositoryResult();
            _resultValue.allowAutoMerge = allowAutoMerge;
            _resultValue.allowMergeCommit = allowMergeCommit;
            _resultValue.allowRebaseMerge = allowRebaseMerge;
            _resultValue.allowSquashMerge = allowSquashMerge;
            _resultValue.allowUpdateBranch = allowUpdateBranch;
            _resultValue.archived = archived;
            _resultValue.defaultBranch = defaultBranch;
            _resultValue.deleteBranchOnMerge = deleteBranchOnMerge;
            _resultValue.description = description;
            _resultValue.fork = fork;
            _resultValue.fullName = fullName;
            _resultValue.gitCloneUrl = gitCloneUrl;
            _resultValue.hasDiscussions = hasDiscussions;
            _resultValue.hasDownloads = hasDownloads;
            _resultValue.hasIssues = hasIssues;
            _resultValue.hasProjects = hasProjects;
            _resultValue.hasWiki = hasWiki;
            _resultValue.homepageUrl = homepageUrl;
            _resultValue.htmlUrl = htmlUrl;
            _resultValue.httpCloneUrl = httpCloneUrl;
            _resultValue.id = id;
            _resultValue.isTemplate = isTemplate;
            _resultValue.mergeCommitMessage = mergeCommitMessage;
            _resultValue.mergeCommitTitle = mergeCommitTitle;
            _resultValue.name = name;
            _resultValue.nodeId = nodeId;
            _resultValue.pages = pages;
            _resultValue.primaryLanguage = primaryLanguage;
            _resultValue.private_ = private_;
            _resultValue.repoId = repoId;
            _resultValue.repositoryLicenses = repositoryLicenses;
            _resultValue.squashMergeCommitMessage = squashMergeCommitMessage;
            _resultValue.squashMergeCommitTitle = squashMergeCommitTitle;
            _resultValue.sshCloneUrl = sshCloneUrl;
            _resultValue.svnUrl = svnUrl;
            _resultValue.templates = templates;
            _resultValue.topics = topics;
            _resultValue.visibility = visibility;
            return _resultValue;
        }
    }
}
