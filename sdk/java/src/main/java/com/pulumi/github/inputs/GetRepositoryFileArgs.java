// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.github.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetRepositoryFileArgs extends com.pulumi.resources.InvokeArgs {

    public static final GetRepositoryFileArgs Empty = new GetRepositoryFileArgs();

    /**
     * Git branch (if omitted, the default repository branch is used, which is usually `main`)
     * The branch must already exist; it will not be created if it does not already exist.
     * 
     */
    @Import(name="branch")
    private @Nullable Output<String> branch;

    /**
     * @return Git branch (if omitted, the default repository branch is used, which is usually `main`)
     * The branch must already exist; it will not be created if it does not already exist.
     * 
     */
    public Optional<Output<String>> branch() {
        return Optional.ofNullable(this.branch);
    }

    /**
     * The path of the file to manage.
     * 
     */
    @Import(name="file", required=true)
    private Output<String> file;

    /**
     * @return The path of the file to manage.
     * 
     */
    public Output<String> file() {
        return this.file;
    }

    /**
     * The repository to read the file from. If an unqualified repo name (without an owner) is passed, the owner will be inferred from the owner of the token used to execute the plan. If a name of the type &#34;owner/repo&#34; (with a slash in the middle) is passed, the owner will be as specified and not the owner of the token.
     * 
     */
    @Import(name="repository", required=true)
    private Output<String> repository;

    /**
     * @return The repository to read the file from. If an unqualified repo name (without an owner) is passed, the owner will be inferred from the owner of the token used to execute the plan. If a name of the type &#34;owner/repo&#34; (with a slash in the middle) is passed, the owner will be as specified and not the owner of the token.
     * 
     */
    public Output<String> repository() {
        return this.repository;
    }

    private GetRepositoryFileArgs() {}

    private GetRepositoryFileArgs(GetRepositoryFileArgs $) {
        this.branch = $.branch;
        this.file = $.file;
        this.repository = $.repository;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetRepositoryFileArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetRepositoryFileArgs $;

        public Builder() {
            $ = new GetRepositoryFileArgs();
        }

        public Builder(GetRepositoryFileArgs defaults) {
            $ = new GetRepositoryFileArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param branch Git branch (if omitted, the default repository branch is used, which is usually `main`)
         * The branch must already exist; it will not be created if it does not already exist.
         * 
         * @return builder
         * 
         */
        public Builder branch(@Nullable Output<String> branch) {
            $.branch = branch;
            return this;
        }

        /**
         * @param branch Git branch (if omitted, the default repository branch is used, which is usually `main`)
         * The branch must already exist; it will not be created if it does not already exist.
         * 
         * @return builder
         * 
         */
        public Builder branch(String branch) {
            return branch(Output.of(branch));
        }

        /**
         * @param file The path of the file to manage.
         * 
         * @return builder
         * 
         */
        public Builder file(Output<String> file) {
            $.file = file;
            return this;
        }

        /**
         * @param file The path of the file to manage.
         * 
         * @return builder
         * 
         */
        public Builder file(String file) {
            return file(Output.of(file));
        }

        /**
         * @param repository The repository to read the file from. If an unqualified repo name (without an owner) is passed, the owner will be inferred from the owner of the token used to execute the plan. If a name of the type &#34;owner/repo&#34; (with a slash in the middle) is passed, the owner will be as specified and not the owner of the token.
         * 
         * @return builder
         * 
         */
        public Builder repository(Output<String> repository) {
            $.repository = repository;
            return this;
        }

        /**
         * @param repository The repository to read the file from. If an unqualified repo name (without an owner) is passed, the owner will be inferred from the owner of the token used to execute the plan. If a name of the type &#34;owner/repo&#34; (with a slash in the middle) is passed, the owner will be as specified and not the owner of the token.
         * 
         * @return builder
         * 
         */
        public Builder repository(String repository) {
            return repository(Output.of(repository));
        }

        public GetRepositoryFileArgs build() {
            $.file = Objects.requireNonNull($.file, "expected parameter 'file' to be non-null");
            $.repository = Objects.requireNonNull($.repository, "expected parameter 'repository' to be non-null");
            return $;
        }
    }

}
