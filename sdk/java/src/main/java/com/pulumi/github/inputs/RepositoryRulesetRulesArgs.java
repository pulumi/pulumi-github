// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.github.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.github.inputs.RepositoryRulesetRulesBranchNamePatternArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesCommitAuthorEmailPatternArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesCommitMessagePatternArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesCommitterEmailPatternArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesPullRequestArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesRequiredDeploymentsArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesRequiredStatusChecksArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesTagNamePatternArgs;
import java.lang.Boolean;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class RepositoryRulesetRulesArgs extends com.pulumi.resources.ResourceArgs {

    public static final RepositoryRulesetRulesArgs Empty = new RepositoryRulesetRulesArgs();

    /**
     * (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
     * 
     */
    @Import(name="branchNamePattern")
    private @Nullable Output<RepositoryRulesetRulesBranchNamePatternArgs> branchNamePattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesBranchNamePatternArgs>> branchNamePattern() {
        return Optional.ofNullable(this.branchNamePattern);
    }

    /**
     * (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    @Import(name="commitAuthorEmailPattern")
    private @Nullable Output<RepositoryRulesetRulesCommitAuthorEmailPatternArgs> commitAuthorEmailPattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesCommitAuthorEmailPatternArgs>> commitAuthorEmailPattern() {
        return Optional.ofNullable(this.commitAuthorEmailPattern);
    }

    /**
     * (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    @Import(name="commitMessagePattern")
    private @Nullable Output<RepositoryRulesetRulesCommitMessagePatternArgs> commitMessagePattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesCommitMessagePatternArgs>> commitMessagePattern() {
        return Optional.ofNullable(this.commitMessagePattern);
    }

    /**
     * (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    @Import(name="committerEmailPattern")
    private @Nullable Output<RepositoryRulesetRulesCommitterEmailPatternArgs> committerEmailPattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesCommitterEmailPatternArgs>> committerEmailPattern() {
        return Optional.ofNullable(this.committerEmailPattern);
    }

    /**
     * (Boolean) Only allow users with bypass permission to create matching refs.
     * 
     */
    @Import(name="creation")
    private @Nullable Output<Boolean> creation;

    /**
     * @return (Boolean) Only allow users with bypass permission to create matching refs.
     * 
     */
    public Optional<Output<Boolean>> creation() {
        return Optional.ofNullable(this.creation);
    }

    /**
     * (Boolean) Only allow users with bypass permissions to delete matching refs.
     * 
     */
    @Import(name="deletion")
    private @Nullable Output<Boolean> deletion;

    /**
     * @return (Boolean) Only allow users with bypass permissions to delete matching refs.
     * 
     */
    public Optional<Output<Boolean>> deletion() {
        return Optional.ofNullable(this.deletion);
    }

    /**
     * (Boolean) Prevent users with push access from force pushing to branches.
     * 
     */
    @Import(name="nonFastForward")
    private @Nullable Output<Boolean> nonFastForward;

    /**
     * @return (Boolean) Prevent users with push access from force pushing to branches.
     * 
     */
    public Optional<Output<Boolean>> nonFastForward() {
        return Optional.ofNullable(this.nonFastForward);
    }

    /**
     * (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
     * 
     */
    @Import(name="pullRequest")
    private @Nullable Output<RepositoryRulesetRulesPullRequestArgs> pullRequest;

    /**
     * @return (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesPullRequestArgs>> pullRequest() {
        return Optional.ofNullable(this.pullRequest);
    }

    /**
     * (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
     * 
     */
    @Import(name="requiredDeployments")
    private @Nullable Output<RepositoryRulesetRulesRequiredDeploymentsArgs> requiredDeployments;

    /**
     * @return (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesRequiredDeploymentsArgs>> requiredDeployments() {
        return Optional.ofNullable(this.requiredDeployments);
    }

    /**
     * (Boolean) Prevent merge commits from being pushed to matching branches.
     * 
     */
    @Import(name="requiredLinearHistory")
    private @Nullable Output<Boolean> requiredLinearHistory;

    /**
     * @return (Boolean) Prevent merge commits from being pushed to matching branches.
     * 
     */
    public Optional<Output<Boolean>> requiredLinearHistory() {
        return Optional.ofNullable(this.requiredLinearHistory);
    }

    /**
     * (Boolean) Commits pushed to matching branches must have verified signatures.
     * 
     */
    @Import(name="requiredSignatures")
    private @Nullable Output<Boolean> requiredSignatures;

    /**
     * @return (Boolean) Commits pushed to matching branches must have verified signatures.
     * 
     */
    public Optional<Output<Boolean>> requiredSignatures() {
        return Optional.ofNullable(this.requiredSignatures);
    }

    /**
     * (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
     * 
     */
    @Import(name="requiredStatusChecks")
    private @Nullable Output<RepositoryRulesetRulesRequiredStatusChecksArgs> requiredStatusChecks;

    /**
     * @return (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesRequiredStatusChecksArgs>> requiredStatusChecks() {
        return Optional.ofNullable(this.requiredStatusChecks);
    }

    /**
     * (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
     * 
     */
    @Import(name="tagNamePattern")
    private @Nullable Output<RepositoryRulesetRulesTagNamePatternArgs> tagNamePattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesTagNamePatternArgs>> tagNamePattern() {
        return Optional.ofNullable(this.tagNamePattern);
    }

    /**
     * (Boolean) Only allow users with bypass permission to update matching refs.
     * 
     */
    @Import(name="update")
    private @Nullable Output<Boolean> update;

    /**
     * @return (Boolean) Only allow users with bypass permission to update matching refs.
     * 
     */
    public Optional<Output<Boolean>> update() {
        return Optional.ofNullable(this.update);
    }

    /**
     * (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
     * 
     */
    @Import(name="updateAllowsFetchAndMerge")
    private @Nullable Output<Boolean> updateAllowsFetchAndMerge;

    /**
     * @return (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
     * 
     */
    public Optional<Output<Boolean>> updateAllowsFetchAndMerge() {
        return Optional.ofNullable(this.updateAllowsFetchAndMerge);
    }

    private RepositoryRulesetRulesArgs() {}

    private RepositoryRulesetRulesArgs(RepositoryRulesetRulesArgs $) {
        this.branchNamePattern = $.branchNamePattern;
        this.commitAuthorEmailPattern = $.commitAuthorEmailPattern;
        this.commitMessagePattern = $.commitMessagePattern;
        this.committerEmailPattern = $.committerEmailPattern;
        this.creation = $.creation;
        this.deletion = $.deletion;
        this.nonFastForward = $.nonFastForward;
        this.pullRequest = $.pullRequest;
        this.requiredDeployments = $.requiredDeployments;
        this.requiredLinearHistory = $.requiredLinearHistory;
        this.requiredSignatures = $.requiredSignatures;
        this.requiredStatusChecks = $.requiredStatusChecks;
        this.tagNamePattern = $.tagNamePattern;
        this.update = $.update;
        this.updateAllowsFetchAndMerge = $.updateAllowsFetchAndMerge;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(RepositoryRulesetRulesArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private RepositoryRulesetRulesArgs $;

        public Builder() {
            $ = new RepositoryRulesetRulesArgs();
        }

        public Builder(RepositoryRulesetRulesArgs defaults) {
            $ = new RepositoryRulesetRulesArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param branchNamePattern (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder branchNamePattern(@Nullable Output<RepositoryRulesetRulesBranchNamePatternArgs> branchNamePattern) {
            $.branchNamePattern = branchNamePattern;
            return this;
        }

        /**
         * @param branchNamePattern (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder branchNamePattern(RepositoryRulesetRulesBranchNamePatternArgs branchNamePattern) {
            return branchNamePattern(Output.of(branchNamePattern));
        }

        /**
         * @param commitAuthorEmailPattern (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder commitAuthorEmailPattern(@Nullable Output<RepositoryRulesetRulesCommitAuthorEmailPatternArgs> commitAuthorEmailPattern) {
            $.commitAuthorEmailPattern = commitAuthorEmailPattern;
            return this;
        }

        /**
         * @param commitAuthorEmailPattern (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder commitAuthorEmailPattern(RepositoryRulesetRulesCommitAuthorEmailPatternArgs commitAuthorEmailPattern) {
            return commitAuthorEmailPattern(Output.of(commitAuthorEmailPattern));
        }

        /**
         * @param commitMessagePattern (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder commitMessagePattern(@Nullable Output<RepositoryRulesetRulesCommitMessagePatternArgs> commitMessagePattern) {
            $.commitMessagePattern = commitMessagePattern;
            return this;
        }

        /**
         * @param commitMessagePattern (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder commitMessagePattern(RepositoryRulesetRulesCommitMessagePatternArgs commitMessagePattern) {
            return commitMessagePattern(Output.of(commitMessagePattern));
        }

        /**
         * @param committerEmailPattern (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder committerEmailPattern(@Nullable Output<RepositoryRulesetRulesCommitterEmailPatternArgs> committerEmailPattern) {
            $.committerEmailPattern = committerEmailPattern;
            return this;
        }

        /**
         * @param committerEmailPattern (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder committerEmailPattern(RepositoryRulesetRulesCommitterEmailPatternArgs committerEmailPattern) {
            return committerEmailPattern(Output.of(committerEmailPattern));
        }

        /**
         * @param creation (Boolean) Only allow users with bypass permission to create matching refs.
         * 
         * @return builder
         * 
         */
        public Builder creation(@Nullable Output<Boolean> creation) {
            $.creation = creation;
            return this;
        }

        /**
         * @param creation (Boolean) Only allow users with bypass permission to create matching refs.
         * 
         * @return builder
         * 
         */
        public Builder creation(Boolean creation) {
            return creation(Output.of(creation));
        }

        /**
         * @param deletion (Boolean) Only allow users with bypass permissions to delete matching refs.
         * 
         * @return builder
         * 
         */
        public Builder deletion(@Nullable Output<Boolean> deletion) {
            $.deletion = deletion;
            return this;
        }

        /**
         * @param deletion (Boolean) Only allow users with bypass permissions to delete matching refs.
         * 
         * @return builder
         * 
         */
        public Builder deletion(Boolean deletion) {
            return deletion(Output.of(deletion));
        }

        /**
         * @param nonFastForward (Boolean) Prevent users with push access from force pushing to branches.
         * 
         * @return builder
         * 
         */
        public Builder nonFastForward(@Nullable Output<Boolean> nonFastForward) {
            $.nonFastForward = nonFastForward;
            return this;
        }

        /**
         * @param nonFastForward (Boolean) Prevent users with push access from force pushing to branches.
         * 
         * @return builder
         * 
         */
        public Builder nonFastForward(Boolean nonFastForward) {
            return nonFastForward(Output.of(nonFastForward));
        }

        /**
         * @param pullRequest (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder pullRequest(@Nullable Output<RepositoryRulesetRulesPullRequestArgs> pullRequest) {
            $.pullRequest = pullRequest;
            return this;
        }

        /**
         * @param pullRequest (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder pullRequest(RepositoryRulesetRulesPullRequestArgs pullRequest) {
            return pullRequest(Output.of(pullRequest));
        }

        /**
         * @param requiredDeployments (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredDeployments(@Nullable Output<RepositoryRulesetRulesRequiredDeploymentsArgs> requiredDeployments) {
            $.requiredDeployments = requiredDeployments;
            return this;
        }

        /**
         * @param requiredDeployments (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredDeployments(RepositoryRulesetRulesRequiredDeploymentsArgs requiredDeployments) {
            return requiredDeployments(Output.of(requiredDeployments));
        }

        /**
         * @param requiredLinearHistory (Boolean) Prevent merge commits from being pushed to matching branches.
         * 
         * @return builder
         * 
         */
        public Builder requiredLinearHistory(@Nullable Output<Boolean> requiredLinearHistory) {
            $.requiredLinearHistory = requiredLinearHistory;
            return this;
        }

        /**
         * @param requiredLinearHistory (Boolean) Prevent merge commits from being pushed to matching branches.
         * 
         * @return builder
         * 
         */
        public Builder requiredLinearHistory(Boolean requiredLinearHistory) {
            return requiredLinearHistory(Output.of(requiredLinearHistory));
        }

        /**
         * @param requiredSignatures (Boolean) Commits pushed to matching branches must have verified signatures.
         * 
         * @return builder
         * 
         */
        public Builder requiredSignatures(@Nullable Output<Boolean> requiredSignatures) {
            $.requiredSignatures = requiredSignatures;
            return this;
        }

        /**
         * @param requiredSignatures (Boolean) Commits pushed to matching branches must have verified signatures.
         * 
         * @return builder
         * 
         */
        public Builder requiredSignatures(Boolean requiredSignatures) {
            return requiredSignatures(Output.of(requiredSignatures));
        }

        /**
         * @param requiredStatusChecks (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredStatusChecks(@Nullable Output<RepositoryRulesetRulesRequiredStatusChecksArgs> requiredStatusChecks) {
            $.requiredStatusChecks = requiredStatusChecks;
            return this;
        }

        /**
         * @param requiredStatusChecks (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredStatusChecks(RepositoryRulesetRulesRequiredStatusChecksArgs requiredStatusChecks) {
            return requiredStatusChecks(Output.of(requiredStatusChecks));
        }

        /**
         * @param tagNamePattern (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder tagNamePattern(@Nullable Output<RepositoryRulesetRulesTagNamePatternArgs> tagNamePattern) {
            $.tagNamePattern = tagNamePattern;
            return this;
        }

        /**
         * @param tagNamePattern (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder tagNamePattern(RepositoryRulesetRulesTagNamePatternArgs tagNamePattern) {
            return tagNamePattern(Output.of(tagNamePattern));
        }

        /**
         * @param update (Boolean) Only allow users with bypass permission to update matching refs.
         * 
         * @return builder
         * 
         */
        public Builder update(@Nullable Output<Boolean> update) {
            $.update = update;
            return this;
        }

        /**
         * @param update (Boolean) Only allow users with bypass permission to update matching refs.
         * 
         * @return builder
         * 
         */
        public Builder update(Boolean update) {
            return update(Output.of(update));
        }

        /**
         * @param updateAllowsFetchAndMerge (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
         * 
         * @return builder
         * 
         */
        public Builder updateAllowsFetchAndMerge(@Nullable Output<Boolean> updateAllowsFetchAndMerge) {
            $.updateAllowsFetchAndMerge = updateAllowsFetchAndMerge;
            return this;
        }

        /**
         * @param updateAllowsFetchAndMerge (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
         * 
         * @return builder
         * 
         */
        public Builder updateAllowsFetchAndMerge(Boolean updateAllowsFetchAndMerge) {
            return updateAllowsFetchAndMerge(Output.of(updateAllowsFetchAndMerge));
        }

        public RepositoryRulesetRulesArgs build() {
            return $;
        }
    }

}
