// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.github.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.github.inputs.RepositoryRulesetRulesBranchNamePatternArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesCommitAuthorEmailPatternArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesCommitMessagePatternArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesCommitterEmailPatternArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesFileExtensionRestrictionArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesFilePathRestrictionArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesMaxFileSizeArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesMergeQueueArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesPullRequestArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesRequiredCodeScanningArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesRequiredDeploymentsArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesRequiredStatusChecksArgs;
import com.pulumi.github.inputs.RepositoryRulesetRulesTagNamePatternArgs;
import java.lang.Boolean;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class RepositoryRulesetRulesArgs extends com.pulumi.resources.ResourceArgs {

    public static final RepositoryRulesetRulesArgs Empty = new RepositoryRulesetRulesArgs();

    /**
     * (Block List, Max: 1) Parameters to be used for the branchNamePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tagNamePattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
     * 
     */
    @Import(name="branchNamePattern")
    private @Nullable Output<RepositoryRulesetRulesBranchNamePatternArgs> branchNamePattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the branchNamePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tagNamePattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesBranchNamePatternArgs>> branchNamePattern() {
        return Optional.ofNullable(this.branchNamePattern);
    }

    /**
     * (Block List, Max: 1) Parameters to be used for the commitAuthorEmailPattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    @Import(name="commitAuthorEmailPattern")
    private @Nullable Output<RepositoryRulesetRulesCommitAuthorEmailPatternArgs> commitAuthorEmailPattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the commitAuthorEmailPattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesCommitAuthorEmailPatternArgs>> commitAuthorEmailPattern() {
        return Optional.ofNullable(this.commitAuthorEmailPattern);
    }

    /**
     * (Block List, Max: 1) Parameters to be used for the commitMessagePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    @Import(name="commitMessagePattern")
    private @Nullable Output<RepositoryRulesetRulesCommitMessagePatternArgs> commitMessagePattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the commitMessagePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesCommitMessagePatternArgs>> commitMessagePattern() {
        return Optional.ofNullable(this.commitMessagePattern);
    }

    /**
     * (Block List, Max: 1) Parameters to be used for the committerEmailPattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    @Import(name="committerEmailPattern")
    private @Nullable Output<RepositoryRulesetRulesCommitterEmailPatternArgs> committerEmailPattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the committerEmailPattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesCommitterEmailPatternArgs>> committerEmailPattern() {
        return Optional.ofNullable(this.committerEmailPattern);
    }

    /**
     * (Boolean) Only allow users with bypass permission to create matching refs.
     * 
     */
    @Import(name="creation")
    private @Nullable Output<Boolean> creation;

    /**
     * @return (Boolean) Only allow users with bypass permission to create matching refs.
     * 
     */
    public Optional<Output<Boolean>> creation() {
        return Optional.ofNullable(this.creation);
    }

    /**
     * (Boolean) Only allow users with bypass permissions to delete matching refs.
     * 
     */
    @Import(name="deletion")
    private @Nullable Output<Boolean> deletion;

    /**
     * @return (Boolean) Only allow users with bypass permissions to delete matching refs.
     * 
     */
    public Optional<Output<Boolean>> deletion() {
        return Optional.ofNullable(this.deletion);
    }

    /**
     * (Block List, Max: 1) Prevent commits that include files with specified file extensions from being pushed to the commit graph. This rule only applies to rulesets with target `push`. (see below for nested schema)
     * 
     */
    @Import(name="fileExtensionRestriction")
    private @Nullable Output<RepositoryRulesetRulesFileExtensionRestrictionArgs> fileExtensionRestriction;

    /**
     * @return (Block List, Max: 1) Prevent commits that include files with specified file extensions from being pushed to the commit graph. This rule only applies to rulesets with target `push`. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesFileExtensionRestrictionArgs>> fileExtensionRestriction() {
        return Optional.ofNullable(this.fileExtensionRestriction);
    }

    /**
     * (Block List, Max 1) Parameters to be used for the filePathRestriction rule. When enabled restricts access to files within the repository. (See below for nested schema)
     * 
     */
    @Import(name="filePathRestriction")
    private @Nullable Output<RepositoryRulesetRulesFilePathRestrictionArgs> filePathRestriction;

    /**
     * @return (Block List, Max 1) Parameters to be used for the filePathRestriction rule. When enabled restricts access to files within the repository. (See below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesFilePathRestrictionArgs>> filePathRestriction() {
        return Optional.ofNullable(this.filePathRestriction);
    }

    /**
     * (Integer) The maximum allowed size, in bytes, of a file.
     * 
     */
    @Import(name="maxFileSize")
    private @Nullable Output<RepositoryRulesetRulesMaxFileSizeArgs> maxFileSize;

    /**
     * @return (Integer) The maximum allowed size, in bytes, of a file.
     * 
     */
    public Optional<Output<RepositoryRulesetRulesMaxFileSizeArgs>> maxFileSize() {
        return Optional.ofNullable(this.maxFileSize);
    }

    /**
     * (Block List, Max: 1) Merges must be performed via a merge queue.
     * 
     */
    @Import(name="mergeQueue")
    private @Nullable Output<RepositoryRulesetRulesMergeQueueArgs> mergeQueue;

    /**
     * @return (Block List, Max: 1) Merges must be performed via a merge queue.
     * 
     */
    public Optional<Output<RepositoryRulesetRulesMergeQueueArgs>> mergeQueue() {
        return Optional.ofNullable(this.mergeQueue);
    }

    /**
     * (Boolean) Prevent users with push access from force pushing to branches.
     * 
     */
    @Import(name="nonFastForward")
    private @Nullable Output<Boolean> nonFastForward;

    /**
     * @return (Boolean) Prevent users with push access from force pushing to branches.
     * 
     */
    public Optional<Output<Boolean>> nonFastForward() {
        return Optional.ofNullable(this.nonFastForward);
    }

    /**
     * (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
     * 
     */
    @Import(name="pullRequest")
    private @Nullable Output<RepositoryRulesetRulesPullRequestArgs> pullRequest;

    /**
     * @return (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesPullRequestArgs>> pullRequest() {
        return Optional.ofNullable(this.pullRequest);
    }

    /**
     * (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
     * 
     */
    @Import(name="requiredCodeScanning")
    private @Nullable Output<RepositoryRulesetRulesRequiredCodeScanningArgs> requiredCodeScanning;

    /**
     * @return (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesRequiredCodeScanningArgs>> requiredCodeScanning() {
        return Optional.ofNullable(this.requiredCodeScanning);
    }

    /**
     * (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
     * 
     */
    @Import(name="requiredDeployments")
    private @Nullable Output<RepositoryRulesetRulesRequiredDeploymentsArgs> requiredDeployments;

    /**
     * @return (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesRequiredDeploymentsArgs>> requiredDeployments() {
        return Optional.ofNullable(this.requiredDeployments);
    }

    /**
     * (Boolean) Prevent merge commits from being pushed to matching branches.
     * 
     */
    @Import(name="requiredLinearHistory")
    private @Nullable Output<Boolean> requiredLinearHistory;

    /**
     * @return (Boolean) Prevent merge commits from being pushed to matching branches.
     * 
     */
    public Optional<Output<Boolean>> requiredLinearHistory() {
        return Optional.ofNullable(this.requiredLinearHistory);
    }

    /**
     * (Boolean) Commits pushed to matching branches must have verified signatures.
     * 
     */
    @Import(name="requiredSignatures")
    private @Nullable Output<Boolean> requiredSignatures;

    /**
     * @return (Boolean) Commits pushed to matching branches must have verified signatures.
     * 
     */
    public Optional<Output<Boolean>> requiredSignatures() {
        return Optional.ofNullable(this.requiredSignatures);
    }

    /**
     * (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
     * 
     */
    @Import(name="requiredStatusChecks")
    private @Nullable Output<RepositoryRulesetRulesRequiredStatusChecksArgs> requiredStatusChecks;

    /**
     * @return (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesRequiredStatusChecksArgs>> requiredStatusChecks() {
        return Optional.ofNullable(this.requiredStatusChecks);
    }

    /**
     * (Block List, Max: 1) Parameters to be used for the tagNamePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branchNamePattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
     * 
     */
    @Import(name="tagNamePattern")
    private @Nullable Output<RepositoryRulesetRulesTagNamePatternArgs> tagNamePattern;

    /**
     * @return (Block List, Max: 1) Parameters to be used for the tagNamePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branchNamePattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
     * 
     */
    public Optional<Output<RepositoryRulesetRulesTagNamePatternArgs>> tagNamePattern() {
        return Optional.ofNullable(this.tagNamePattern);
    }

    /**
     * (Boolean) Only allow users with bypass permission to update matching refs.
     * 
     */
    @Import(name="update")
    private @Nullable Output<Boolean> update;

    /**
     * @return (Boolean) Only allow users with bypass permission to update matching refs.
     * 
     */
    public Optional<Output<Boolean>> update() {
        return Optional.ofNullable(this.update);
    }

    /**
     * (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
     * 
     */
    @Import(name="updateAllowsFetchAndMerge")
    private @Nullable Output<Boolean> updateAllowsFetchAndMerge;

    /**
     * @return (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
     * 
     */
    public Optional<Output<Boolean>> updateAllowsFetchAndMerge() {
        return Optional.ofNullable(this.updateAllowsFetchAndMerge);
    }

    private RepositoryRulesetRulesArgs() {}

    private RepositoryRulesetRulesArgs(RepositoryRulesetRulesArgs $) {
        this.branchNamePattern = $.branchNamePattern;
        this.commitAuthorEmailPattern = $.commitAuthorEmailPattern;
        this.commitMessagePattern = $.commitMessagePattern;
        this.committerEmailPattern = $.committerEmailPattern;
        this.creation = $.creation;
        this.deletion = $.deletion;
        this.fileExtensionRestriction = $.fileExtensionRestriction;
        this.filePathRestriction = $.filePathRestriction;
        this.maxFileSize = $.maxFileSize;
        this.mergeQueue = $.mergeQueue;
        this.nonFastForward = $.nonFastForward;
        this.pullRequest = $.pullRequest;
        this.requiredCodeScanning = $.requiredCodeScanning;
        this.requiredDeployments = $.requiredDeployments;
        this.requiredLinearHistory = $.requiredLinearHistory;
        this.requiredSignatures = $.requiredSignatures;
        this.requiredStatusChecks = $.requiredStatusChecks;
        this.tagNamePattern = $.tagNamePattern;
        this.update = $.update;
        this.updateAllowsFetchAndMerge = $.updateAllowsFetchAndMerge;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(RepositoryRulesetRulesArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private RepositoryRulesetRulesArgs $;

        public Builder() {
            $ = new RepositoryRulesetRulesArgs();
        }

        public Builder(RepositoryRulesetRulesArgs defaults) {
            $ = new RepositoryRulesetRulesArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param branchNamePattern (Block List, Max: 1) Parameters to be used for the branchNamePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tagNamePattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder branchNamePattern(@Nullable Output<RepositoryRulesetRulesBranchNamePatternArgs> branchNamePattern) {
            $.branchNamePattern = branchNamePattern;
            return this;
        }

        /**
         * @param branchNamePattern (Block List, Max: 1) Parameters to be used for the branchNamePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tagNamePattern` as it only applied to rulesets with target `branch`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder branchNamePattern(RepositoryRulesetRulesBranchNamePatternArgs branchNamePattern) {
            return branchNamePattern(Output.of(branchNamePattern));
        }

        /**
         * @param commitAuthorEmailPattern (Block List, Max: 1) Parameters to be used for the commitAuthorEmailPattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder commitAuthorEmailPattern(@Nullable Output<RepositoryRulesetRulesCommitAuthorEmailPatternArgs> commitAuthorEmailPattern) {
            $.commitAuthorEmailPattern = commitAuthorEmailPattern;
            return this;
        }

        /**
         * @param commitAuthorEmailPattern (Block List, Max: 1) Parameters to be used for the commitAuthorEmailPattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder commitAuthorEmailPattern(RepositoryRulesetRulesCommitAuthorEmailPatternArgs commitAuthorEmailPattern) {
            return commitAuthorEmailPattern(Output.of(commitAuthorEmailPattern));
        }

        /**
         * @param commitMessagePattern (Block List, Max: 1) Parameters to be used for the commitMessagePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder commitMessagePattern(@Nullable Output<RepositoryRulesetRulesCommitMessagePatternArgs> commitMessagePattern) {
            $.commitMessagePattern = commitMessagePattern;
            return this;
        }

        /**
         * @param commitMessagePattern (Block List, Max: 1) Parameters to be used for the commitMessagePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder commitMessagePattern(RepositoryRulesetRulesCommitMessagePatternArgs commitMessagePattern) {
            return commitMessagePattern(Output.of(commitMessagePattern));
        }

        /**
         * @param committerEmailPattern (Block List, Max: 1) Parameters to be used for the committerEmailPattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder committerEmailPattern(@Nullable Output<RepositoryRulesetRulesCommitterEmailPatternArgs> committerEmailPattern) {
            $.committerEmailPattern = committerEmailPattern;
            return this;
        }

        /**
         * @param committerEmailPattern (Block List, Max: 1) Parameters to be used for the committerEmailPattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder committerEmailPattern(RepositoryRulesetRulesCommitterEmailPatternArgs committerEmailPattern) {
            return committerEmailPattern(Output.of(committerEmailPattern));
        }

        /**
         * @param creation (Boolean) Only allow users with bypass permission to create matching refs.
         * 
         * @return builder
         * 
         */
        public Builder creation(@Nullable Output<Boolean> creation) {
            $.creation = creation;
            return this;
        }

        /**
         * @param creation (Boolean) Only allow users with bypass permission to create matching refs.
         * 
         * @return builder
         * 
         */
        public Builder creation(Boolean creation) {
            return creation(Output.of(creation));
        }

        /**
         * @param deletion (Boolean) Only allow users with bypass permissions to delete matching refs.
         * 
         * @return builder
         * 
         */
        public Builder deletion(@Nullable Output<Boolean> deletion) {
            $.deletion = deletion;
            return this;
        }

        /**
         * @param deletion (Boolean) Only allow users with bypass permissions to delete matching refs.
         * 
         * @return builder
         * 
         */
        public Builder deletion(Boolean deletion) {
            return deletion(Output.of(deletion));
        }

        /**
         * @param fileExtensionRestriction (Block List, Max: 1) Prevent commits that include files with specified file extensions from being pushed to the commit graph. This rule only applies to rulesets with target `push`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder fileExtensionRestriction(@Nullable Output<RepositoryRulesetRulesFileExtensionRestrictionArgs> fileExtensionRestriction) {
            $.fileExtensionRestriction = fileExtensionRestriction;
            return this;
        }

        /**
         * @param fileExtensionRestriction (Block List, Max: 1) Prevent commits that include files with specified file extensions from being pushed to the commit graph. This rule only applies to rulesets with target `push`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder fileExtensionRestriction(RepositoryRulesetRulesFileExtensionRestrictionArgs fileExtensionRestriction) {
            return fileExtensionRestriction(Output.of(fileExtensionRestriction));
        }

        /**
         * @param filePathRestriction (Block List, Max 1) Parameters to be used for the filePathRestriction rule. When enabled restricts access to files within the repository. (See below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder filePathRestriction(@Nullable Output<RepositoryRulesetRulesFilePathRestrictionArgs> filePathRestriction) {
            $.filePathRestriction = filePathRestriction;
            return this;
        }

        /**
         * @param filePathRestriction (Block List, Max 1) Parameters to be used for the filePathRestriction rule. When enabled restricts access to files within the repository. (See below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder filePathRestriction(RepositoryRulesetRulesFilePathRestrictionArgs filePathRestriction) {
            return filePathRestriction(Output.of(filePathRestriction));
        }

        /**
         * @param maxFileSize (Integer) The maximum allowed size, in bytes, of a file.
         * 
         * @return builder
         * 
         */
        public Builder maxFileSize(@Nullable Output<RepositoryRulesetRulesMaxFileSizeArgs> maxFileSize) {
            $.maxFileSize = maxFileSize;
            return this;
        }

        /**
         * @param maxFileSize (Integer) The maximum allowed size, in bytes, of a file.
         * 
         * @return builder
         * 
         */
        public Builder maxFileSize(RepositoryRulesetRulesMaxFileSizeArgs maxFileSize) {
            return maxFileSize(Output.of(maxFileSize));
        }

        /**
         * @param mergeQueue (Block List, Max: 1) Merges must be performed via a merge queue.
         * 
         * @return builder
         * 
         */
        public Builder mergeQueue(@Nullable Output<RepositoryRulesetRulesMergeQueueArgs> mergeQueue) {
            $.mergeQueue = mergeQueue;
            return this;
        }

        /**
         * @param mergeQueue (Block List, Max: 1) Merges must be performed via a merge queue.
         * 
         * @return builder
         * 
         */
        public Builder mergeQueue(RepositoryRulesetRulesMergeQueueArgs mergeQueue) {
            return mergeQueue(Output.of(mergeQueue));
        }

        /**
         * @param nonFastForward (Boolean) Prevent users with push access from force pushing to branches.
         * 
         * @return builder
         * 
         */
        public Builder nonFastForward(@Nullable Output<Boolean> nonFastForward) {
            $.nonFastForward = nonFastForward;
            return this;
        }

        /**
         * @param nonFastForward (Boolean) Prevent users with push access from force pushing to branches.
         * 
         * @return builder
         * 
         */
        public Builder nonFastForward(Boolean nonFastForward) {
            return nonFastForward(Output.of(nonFastForward));
        }

        /**
         * @param pullRequest (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder pullRequest(@Nullable Output<RepositoryRulesetRulesPullRequestArgs> pullRequest) {
            $.pullRequest = pullRequest;
            return this;
        }

        /**
         * @param pullRequest (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder pullRequest(RepositoryRulesetRulesPullRequestArgs pullRequest) {
            return pullRequest(Output.of(pullRequest));
        }

        /**
         * @param requiredCodeScanning (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredCodeScanning(@Nullable Output<RepositoryRulesetRulesRequiredCodeScanningArgs> requiredCodeScanning) {
            $.requiredCodeScanning = requiredCodeScanning;
            return this;
        }

        /**
         * @param requiredCodeScanning (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredCodeScanning(RepositoryRulesetRulesRequiredCodeScanningArgs requiredCodeScanning) {
            return requiredCodeScanning(Output.of(requiredCodeScanning));
        }

        /**
         * @param requiredDeployments (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredDeployments(@Nullable Output<RepositoryRulesetRulesRequiredDeploymentsArgs> requiredDeployments) {
            $.requiredDeployments = requiredDeployments;
            return this;
        }

        /**
         * @param requiredDeployments (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredDeployments(RepositoryRulesetRulesRequiredDeploymentsArgs requiredDeployments) {
            return requiredDeployments(Output.of(requiredDeployments));
        }

        /**
         * @param requiredLinearHistory (Boolean) Prevent merge commits from being pushed to matching branches.
         * 
         * @return builder
         * 
         */
        public Builder requiredLinearHistory(@Nullable Output<Boolean> requiredLinearHistory) {
            $.requiredLinearHistory = requiredLinearHistory;
            return this;
        }

        /**
         * @param requiredLinearHistory (Boolean) Prevent merge commits from being pushed to matching branches.
         * 
         * @return builder
         * 
         */
        public Builder requiredLinearHistory(Boolean requiredLinearHistory) {
            return requiredLinearHistory(Output.of(requiredLinearHistory));
        }

        /**
         * @param requiredSignatures (Boolean) Commits pushed to matching branches must have verified signatures.
         * 
         * @return builder
         * 
         */
        public Builder requiredSignatures(@Nullable Output<Boolean> requiredSignatures) {
            $.requiredSignatures = requiredSignatures;
            return this;
        }

        /**
         * @param requiredSignatures (Boolean) Commits pushed to matching branches must have verified signatures.
         * 
         * @return builder
         * 
         */
        public Builder requiredSignatures(Boolean requiredSignatures) {
            return requiredSignatures(Output.of(requiredSignatures));
        }

        /**
         * @param requiredStatusChecks (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredStatusChecks(@Nullable Output<RepositoryRulesetRulesRequiredStatusChecksArgs> requiredStatusChecks) {
            $.requiredStatusChecks = requiredStatusChecks;
            return this;
        }

        /**
         * @param requiredStatusChecks (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder requiredStatusChecks(RepositoryRulesetRulesRequiredStatusChecksArgs requiredStatusChecks) {
            return requiredStatusChecks(Output.of(requiredStatusChecks));
        }

        /**
         * @param tagNamePattern (Block List, Max: 1) Parameters to be used for the tagNamePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branchNamePattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder tagNamePattern(@Nullable Output<RepositoryRulesetRulesTagNamePatternArgs> tagNamePattern) {
            $.tagNamePattern = tagNamePattern;
            return this;
        }

        /**
         * @param tagNamePattern (Block List, Max: 1) Parameters to be used for the tagNamePattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branchNamePattern` as it only applied to rulesets with target `tag`. (see below for nested schema)
         * 
         * @return builder
         * 
         */
        public Builder tagNamePattern(RepositoryRulesetRulesTagNamePatternArgs tagNamePattern) {
            return tagNamePattern(Output.of(tagNamePattern));
        }

        /**
         * @param update (Boolean) Only allow users with bypass permission to update matching refs.
         * 
         * @return builder
         * 
         */
        public Builder update(@Nullable Output<Boolean> update) {
            $.update = update;
            return this;
        }

        /**
         * @param update (Boolean) Only allow users with bypass permission to update matching refs.
         * 
         * @return builder
         * 
         */
        public Builder update(Boolean update) {
            return update(Output.of(update));
        }

        /**
         * @param updateAllowsFetchAndMerge (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
         * 
         * @return builder
         * 
         */
        public Builder updateAllowsFetchAndMerge(@Nullable Output<Boolean> updateAllowsFetchAndMerge) {
            $.updateAllowsFetchAndMerge = updateAllowsFetchAndMerge;
            return this;
        }

        /**
         * @param updateAllowsFetchAndMerge (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
         * 
         * @return builder
         * 
         */
        public Builder updateAllowsFetchAndMerge(Boolean updateAllowsFetchAndMerge) {
            return updateAllowsFetchAndMerge(Output.of(updateAllowsFetchAndMerge));
        }

        public RepositoryRulesetRulesArgs build() {
            return $;
        }
    }

}
